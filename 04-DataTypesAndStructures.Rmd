# Data Types and Structures {#datatypes}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 10, fig.height = 5,
                      comment = NA, cache = TRUE) 
options(rt.theme = "lightgrid")
options(rt.fit.theme = "lightgrid")
```

```{r, comment="", results="asis", echo=FALSE}
old.hooks <- fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE)
```

Something to keep in mind:  
In R, any "thing" is an object and any "action" is a function.  
That's it - there are "objects" of various kinds, many of them described here.  
Functions are described in [chapter on functions](#functions).

## Assignment
Use `<-` for all assignments
```{r}
x <- 3
# You can add comments within code blocks using the usual "#" prefix
```
Typing the name of an object...
```{r}
x
```
...is equivalent to printing it

```{r}
print(x)
```

You can also place any assignment in parenthesis and this will perform the assignment and print the object:
```{r}
(x <- 3)
```

Note: While you *could* use the equal sign '=' for assignment, you should  only use it to pass arguments to functions.  

You can assign the same value to multiple objects - can be helpful when initializing.
```{r}
x <- z <- init <- 0
x
z
init
```

Excitingly, R allows assignment in the opposite direction as well:
```{r}
10 -> x
x
```

or even:
```{r}
x <- 7 -> z
x
z
```

We shall see later that the `->` assignment can be convenient at the end of a [pipe](https://rtemis.netlify.com/biostat214/functions.html#the-pipe-operator).

## Data types a.k.a Base types
R includes a number of builtin data types. (These are defined by the R core team - users cannot define their own data types, but they can define their own classes - see section on Object-Oriented Programming).  
Some of the more popular data types in R include:

* Logical
* Numeric, integer
* Numeric, double
* Character
* Environment
* Closure (function + environment)

Many errors in R occur because a variable is -or gets converted to- the wrong type by accident.  
**Check variable types with `str()` and/or `typeof()`.**

### Logical 
If you are writing code, use `TRUE` and `FALSE`.  
On the console, you can abbreviate to `T` and `F`.
```{r}
a <- c(TRUE, FALSE)
a <- c(T, F)
x <- 4
b <- x > 10
str(b)
typeof(b)
b
```

### Integer
Assign a range of integers:
```{r}
(x <- 1:5)
str(x)
typeof(x)
```

```{r}
x <- 1 # defaults to double
str(x)
typeof(x)
```

Force integer by adding a pretty "L" suffix
```{r}
x <- 1L
str(x)
typeof(x)
```

### Double
```{r}
x <- c(1.2, 3.4, 10.987632419834556)
x
str(x)
typeof(x)
```

### Character
```{r}
x <- "word"
typeof(x)
```

### Environment
```{r}
x <- new.env()
x$name <- "Guava"
x$founded <- 2020
x
typeof(x)
```

### Closure
```{r}
square <- function(x) x^2
square(3)
typeof(square)
```

## Create - coerce - test
You can create / initialize vectors of specific type with the `vector` command and specifying a `mode` or directly by calling the appropriate function:
```{r}
(xl <- vector(mode = "logical", length = 10))
(xd <- vector(mode = "double", length = 10))
(xn <- vector(mode = "numeric", length = 10)) # same as "double"
(xi <- vector(mode = "integer", length = 10))
(xc <- vector(mode = "character", length = 10))
```

These are aliases of the `vector` command above (print their source code to see for yourself)
```{r}
xl <- logical(10)
xd <- double(10)
xn <- numeric(10) # same as double
xi <- integer(10)
xc <- character(10)
```

## Explicit coercion
We can explicitly convert objects of one class to a different class using one of many available `as.*` functions.
```{r}
x <- c(1.2, 2.3)
as.logical(x)
as.double(x)
as.numeric(x)
as.integer(x)
as.character(x)
```

Factors can be converted to numbers (integers) which denote which level each element represents.
```{r}
x <- factor(c("mango", "tangerine", "banana", "mango", "banana"),
            levels = c("mango", "banana", "tangerine"))
class(x)
typeof(x)
is.numeric(x)
is.factor(x)
as.numeric(x)
as.integer(x)
as.double(x)
as.character(x)
```

Logical vectors are converted to 1s and 0s as expected: TRUE becomes 1 and FALSE becomes 0
```{r}
x <- c(TRUE, TRUE, FALSE)
as.numeric(x)
```

Note that going the other way, i.e. from numeric to logical, anything other than zero is TRUE:
```{r}
x <- seq(-2, 2, .5)
as.logical(x)
```


Not all conversions are possible. There is no way to come up with a number of a character vector. The following outputs NA values and prints a (helpful) error message.
```{r}
x <- c("mango", "banana", "tangerine")
as.numeric(x)
```

## Implicit coercion
Remember, the language tries to make life easier and will often automatically coerce from one class to another to make requested operations possible.

For example, you can sum a logical vector. It will automatically be converted to numeric as we saw earlier.
```{r}
x <- c(TRUE, TRUE, FALSE)
sum(x)
```

On the other hand, you cannot sum a factor, for example. You get an error and an explanation:
```{r error = TRUE}
x <- factor(c("mango", "banana", "mango"))
sum(x)
```

Note: we added `error = TRUE` in the code block's options, because otherwise compilation of the Rmarkdown document would stop at the error.

Yes, if for some reason it made sense, you could explicitly coerce to numeric and then sum:
```{r}
x <- factor(c("mango", "banana", "mango"))
sum(as.numeric(x))
```

## Missing values (`NA`)
Missing values in R are coded as `NA`.  
Let's create a matrix with values drawn at random from a normal distribution and replace some of them with `NA`:
```{r}
a <- sapply(1:10, function(i) rnorm(30))
dim(a)
a[1, 5] <- a[1, 7] <- a[1, 9] <- a[1, 10] <- a[12, 9] <- 
  a[20, 9] <- a[27, 6] <- a[29, 6] <- NA
```

### Count NAs by columnn and row using `apply`
We will create a so-called anonymous function within `apply`.
```{r}
total.NAs.byRow <- apply(a, 1, function(i)  sum(is.na(i)))
total.NAs.byCol <- apply(a, 2, function(i)  sum(is.na(i)))

index.NAs <- is.na(a)
apply(index.NAs, 1, sum)
apply(index.NAs, 2, sum)
```

### Some operations result in `NA` values
This can be normal and expected, or suggest an error. It may be worth checking your output for `NA` values.
```{r}
x <- -5:5
(logx <- log(x))
anyNA(logx)
```

## Data Structures
There are 5 main data structures in R:  

* Vector: 1-dimensional; homogeneous
* Matrix: 2-dimensional; homogeneous
* Array: N-dimensional; homogeneous
* List: 1 main dimension, but can be nested; heterogeneous
* Data frame: 2-dimensional: A special type of list; heterogeneous

Homogeneous vs. hetereogeneous refers to the kind of data types (integer, double, character, logical, factor, etc.) that a structure can hold. This means a matrix can hold only numbers or only characters, but a data frame can hold different types in different columns. That is why data frames are very popular data structure for statistical work.

### Vectors
```{r}
(x1 <- c(1, 3, 5, 7))
class(x1)
typeof(x1)
```

```{r}
(x2 <- 1:10)
(x3 <- rnorm(10))
(x4 <- seq(0, 1, .1))
seq(10)
(x5 <- sample(seq(100), 20))
```

#### Generating sequences with seq
1. from, to, by
```{r}
seq(1, 10, .5)
```

2. 1:n
```{r}
(seq(12))
(seq_len(12))
```

3. Along the length of another object
```{r}
seq_along(iris)
1:ncol(iris)
```

4. from, to with n length
```{r}
seq(-5, 12, length.out = 11)
```

#### Initializing a vector
```{r}
x <- vector(length = 10)
x <- vector("numeric", 10)
x <- vector("list", 10)
```

### Matrices
```{r}
x <- matrix(sample(seq(1000), 30), nrow = 10, ncol = 3)
x
class(x)
```

#### Construct by row or by column
By default, vectors are constructed by column (byrow = FALSE)
```{r}
x <- matrix(1:20, nrow = 10, ncol = 2, byrow = FALSE)
x
```

```{r}
x <- matrix(1:20, nrow = 10, ncol = 2, byrow = TRUE)
x
```

#### Initialize a matrix
```{r}
(x <- matrix(NA, nrow = 6, ncol = 4))
(x <- matrix(0, nrow = 6, ncol = 4))
```

#### Bind vectors by column or by row

```{r}
x <- cbind(1:10, 11:20, 41:50)
x
```

```{r}
x <- rbind(1:10, 11:20, 41:50)
x
```

### Lists
```{r}
x <- list(one = 1:4,
          two = sample(seq(0, 100, .1), 10),
          three = c("mango", "banana", "tangerine"),
          four = median)
class(x)
str(x)
```

#### Initialize a list
```{r}
x <- vector("list", 4)
x
```

###  Data frames
Note: Data frames are specialized lists!

```{r}
x <- data.frame(Feat_1 = 1:5,
                Feat_2 = rnorm(5),
                Feat_3 = paste0("rnd_", sample(seq(100), 5)))
x
class(x)
str(x)
class(x$Feat_1)
```

```{r}
mat <- matrix(1:100, 10)
length(mat)
df <- as.data.frame(mat)
length(df)
```

### Arrays
A 1D array is not a vector
```{r}
x <- 1:10
xa <- array(1:10, dim = 10)
class(x)
class(xa)
```

A 2D array is a matrix
```{r}
x <- array(1:40, dim = c(10, 4))
class(x)
dim(x)
```

An ND array is an ND array (N-dimensional array)
```{r}
x <- array(sample(1:255, 432, TRUE), dim = c(12, 12, 3))
class(x)
```

```{r}
x <- array(sample(1:255, 432, TRUE), dim = c(12, 12, 3))
par("pty")
par(pty = "s")
plot(NULL, NULL,
     xlim = c(0, 100), ylim = c(0, 100),
     axes = F, ann = F, pty = "s")
rasterImage(x/255, 0, 0, 100, 100)
```

```{r}
n4 <- array(sample(1:255, 600, TRUE), dim = c(10, 4, 3, 5))
```

### Factors
Factors are used to store categorical data and they have many important uses in statistics and data science.
```{r}
(x <- factor(c("a", "b", "c", "d", "a", "a", "d", "c")))
```
In R, a factor is stored as vector of integers indexing a set of levels.  
`str` of a factor outputs  

* the number of levels
* the levels, in order
* the vector as an integer index of the levels
```{r}
str(x)
```
You can define the levels and their order using the `levels` argument in `factor()`. If undefined, the levels will be set to the unique values of the input vector sorted alphabetically.  
In many cases we want to define levels in a specific order.
```{r}
(x <- factor(c("alpha", "alpha", "beta", "delta", "delta")))
table(x)
(x <- factor(c("alpha", "alpha", "beta", "delta", "delta"),
            levels = c("alpha", "beta", "gamma", "delta")))
class(x)
table(x)
```

```{r}
levels(x)
```

Setting new levels with `levels` *changes all values*
```{r}
xe <- x
levels(xe) <- c("a", "b", "c", "d")
xe
```

You can change the order of the levels, without changing the values
```{r}
xr <- factor(as.character(x), levels = c("delta", "gamma", "beta", "alpha"))
xr
```

#### Factors can be ordered
```{r}
x <- factor(c("low", "low", "high", "low", "mid", 
              "mid", "high", "low", "high", "mid"),
            levels = c("low", "mid", "high"),
            ordered = TRUE)
x
class(x)
```


## Attributes
R objects may have some builtin attributes but you can add arbitrary attributes to any R objects. These are used to store additional information, sometimes called metadata, about an object.  

### Read attributes
To read an object's attributes, use `attributes`:
```{r}
attributes(iris)
```
This returns a named list. In this case we got names, class, and row.names of the iris data frame.  

### Add attributes
You can assign new attributes using `attr`:
```{r}
(x <- c(1:10))
attr(x, "name") <- "Very special vector"
```

Printing the vector after adding a new attribute, prints the attribute name and value underneath the vector itself:
```{r}
x
```

Our trusty `str` function will print attributes as well
```{r}
str(x)
```

### Common builtin attributes
Vectors can have named elements. A new vector has no names, but you can add them:
```{r}
x <- rnorm(10)
names(x)
names(x) <- paste0("Value", seq(x))
x
```

Matrices and data frames can have column names (`colnames`) and row names (`rownames`):
```{r}
x <- matrix(1:15, 5)
colnames(x)
rownames(x)
colnames(x) <- paste0("Feature", seq(3))
rownames(x) <- paste0("Case", seq(5))
x
```

Lists are vectors so they have `names`. These can be defined when a list is created using the name-value pairs or added/changed at any time.
```{r}
x <- list(HospitalName = "CaliforniaGeneral",
          ParticipatingDepartments = c("Neurology", "Psychiatry", "Neurosurgery"),
          PatientIDs = 1001:1253)
names(x)
```

Add/Change names:
```{r}
names(x) <- c("Hospital", "Departments", "PIDs")
x
```

Note: Remember that data a frame is a special type of list. Therefore in data frames `colnames` and `names` are equivalent:
```{r}
colnames(iris)
names(iris)
```

Note: As we saw, matrices have `colnames` and `rownames.` Using `names` on a matrix will assign names to *individual elements*, as if it was a long vector - this is not usually very useful.