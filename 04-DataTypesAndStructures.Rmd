# Data Types and Structures {#datatypes}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 10, fig.height = 5,
                      comment = NA, cache = TRUE) 
options(rt.theme = "lightgrid")
options(rt.fit.theme = "lightgrid")
```

```{r, comment="", results="asis", echo=FALSE}
old.hooks <- fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE)
```

```{block, type="Note"}
In R, everything is an object.
Every "action" is a function.
[Functions](#functions) are also objects, which means they be passed as arguments to functions or returned from other functions.
We shall see the relevance of this, for example, in the [Loop Functions](#loopfns) chapter.
```

## Assignment

Use `<-` for all assignments

```{r}
x <- 3
# You can add comments within code blocks using the usual "#" prefix
```

Typing the name of an object...

```{r}
x
```
...is equivalent to printing it

```{r}
print(x)
```

You can also place any assignment in parentheses and this will perform the assignment and print the object:

```{r}
(x <- 3)
```

Note: While you *could* use the equal sign '=' for assignment, you should only use it when passing arguments to functions.  

You can assign the same value to multiple objects - this can be useful when initializing variables.

```{r}
x <- z <- init <- 0
x
z
init
```

Excitingly, R allows assignment in the opposite direction as well:

```{r}
10 -> x
x
```

We shall see later that the `->` assignment can be convenient at the end of a [pipe](https://class.lambdamd.org/progdatscir/functions.html#the-pipe-operator).

You can even do this, which is fun (?) but unlikely to be useful:

```{r}
x <- 7 -> z
x
z
```

## Data types a.k.a Base types

R includes a number of builtin data types.  

These are defined by the R core team: users cannot define their own data types, but they can define their own classes - see section on [Classes and Object-Oriented Programming](#classes).  

Some of the more popular data types in R are:

* Logical (a.k.a. [Boolean](https://en.wikipedia.org/wiki/Boolean_data_type))
* Numeric, integer
* Numeric, [double](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)
* Character
* Environment
* Closure (i.e. function)

```{block, type="Warning"}
Many errors in R occur because a variable is, or gets coerced to, the wrong type by accident.
```

**Check variable types with `str()` and/or `typeof()`.**

### Logical 

If you are writing code, use `TRUE` and `FALSE`.  
On the console, you can abbreviate to `T` and `F`.

```{r}
a <- c(TRUE, FALSE)
a <- c(T, F)
x <- 4
b <- x > 10
str(b)
typeof(b)
b
```

### Integer

Assign a range of integers:

```{r}
(x <- 1:5)
str(x)
typeof(x)
```

```{r}
x <- 1 # defaults to double
str(x)
typeof(x)
```

Force integer by adding a pretty "L" suffix

```{r}
x <- 1L
str(x)
typeof(x)
```

### Double

```{r}
x <- c(1.2, 3.4, 10.987632419834556)
x
str(x)
typeof(x)
```

### Character

```{r}
x <- "word"
typeof(x)
```

### Environment

```{r}
x <- new.env()
x$name <- "Guava"
x$founded <- 2020
x
typeof(x)
```

### Closure (function)

```{r}
square <- function(x) x^2
square(3)
typeof(square)
```

## Create - coerce - test

You can create / initialize vectors of specific type with the `vector` command and specifying a `mode` or directly by calling the appropriate function:

```{r}
(xl <- vector(mode = "logical", length = 10))
(xd <- vector(mode = "double", length = 10))
(xn <- vector(mode = "numeric", length = 10)) # same as "double"
(xi <- vector(mode = "integer", length = 10))
(xc <- vector(mode = "character", length = 10))
```

These are aliases of the `vector` command above (print their source code to see for yourself)

```{r}
xl <- logical(10)
xd <- double(10)
xn <- numeric(10) # same as double
xi <- integer(10)
xc <- character(10)
```

## Explicit coercion

We can explicitly convert objects of one class to a different class using one of many available `as.*` functions.

```{r}
x <- c(1.2, 2.3)
as.logical(x)
as.double(x)
as.numeric(x)
as.integer(x)
as.character(x)
```

Factors can be converted to numbers (integers) which denote which level each element represents.

```{r}
x <- factor(c("mango", "tangerine", "banana", "mango", "banana"),
            levels = c("mango", "banana", "tangerine"))
class(x)
typeof(x)
is.numeric(x)
is.factor(x)
as.numeric(x)
as.integer(x)
as.double(x)
as.character(x)
```

Logical vectors are converted to 1s and 0s as expected:  

TRUE becomes 1 and FALSE becomes 0

```{r}
x <- c(TRUE, TRUE, FALSE)
as.numeric(x)
```

Note that going the other way, i.e. from numeric to logical,  
**anything other than zero is TRUE**:

```{r}
x <- seq(-2, 2, .5)
as.logical(x)
```


Not all conversions are possible.  
There is no meaningful/consistent way to come up with a number for a character vector.  
The following outputs NA values and prints a (helpful) error message.

```{r}
x <- c("mango", "banana", "tangerine")
as.numeric(x)
```

## Implicit coercion

Remember, the language tries to make life easier and will often automatically coerce from one class to another to make requested operations possible.

For example, you can sum a logical vector.  
It will automatically be converted to numeric as we saw earlier.

```{r}
x <- c(TRUE, TRUE, FALSE)
sum(x)
```

On the other hand, you cannot sum a factor, for example.  
You get an error with an explanation:

```{r error = TRUE}
x <- factor(c("mango", "banana", "mango"))
sum(x)
```

```{block, type="Note"}
Note: We had to add `error = TRUE` in the Rmarkdown's code block's options (not visible in the HTML output), because otherwise compilation of the Rmarkdown document would stop at the error.
```

Yes, if for some reason it made sense, you could explicitly coerce to numeric and then sum:

```{r}
x <- factor(c("mango", "banana", "mango"))
sum(as.numeric(x))
```

## Missing values (`NA`)

Missing values in R are coded as `NA`.  
Let's create a matrix with values drawn at random from a normal distribution and replace some of them with `NA`:

```{r}
a <- sapply(1:10, function(i) rnorm(30))
dim(a)
a[1, 5] <- a[1, 7] <- a[1, 9] <- a[1, 10] <- a[12, 9] <- 
  a[20, 9] <- a[27, 6] <- a[29, 6] <- NA
```

### Count NAs by columnn and row using `apply`

We will create a so-called anonymous function within `apply`.

```{r}
total.NAs.byRow <- apply(a, 1, function(i)  sum(is.na(i)))
total.NAs.byCol <- apply(a, 2, function(i)  sum(is.na(i)))

index.NAs <- is.na(a)
apply(index.NAs, 1, sum)
apply(index.NAs, 2, sum)
```

### Some operations result in `NA` values

This can be normal and expected, or suggest an error.  
It may be worth checking your output for `NA` values.

```{r}
x <- -5:5
(logx <- log(x))
anyNA(logx)
```

## Data Structures

There are 5 main data structures in R:  

* Vector: 1-dimensional homogeneous collection
* Matrix: 2-dimensional homogeneous collection
* Array: N-dimensional homogeneous collection
* List: 1 main dimension, but can be nested; heterogeneous collection
* Data frame: 2-dimensional: A special type of list; heterogeneous collection of columns

Homogeneous vs. hetereogeneous refers to the kind of data types (integer, double, character, logical, factor, etc.) that a structure can hold. This means a matrix can hold only numbers or only characters, but a data frame can hold different types in different columns. That is why data frames are very popular data structure for statistical work.

### Vectors

```{r}
(x1 <- c(1, 3, 5, 7))
class(x1)
typeof(x1)
```

```{r}
(x2 <- 1:10)
(x3 <- rnorm(10))
(x4 <- seq(0, 1, .1))
seq(10)
(x5 <- sample(seq(100), 20))
```

#### Generating sequences with `seq()`

1. from, to, by

```{r}
seq(1, 10, .5)
```

2. 1:n

```{r}
(seq(12))
(seq_len(12))
```

3. Along the length of another object

```{r}
seq_along(iris)
1:ncol(iris)
```

4. `from`, `to` with length `n`

```{r}
seq(-5, 12, length.out = 11)
```

#### Initializing a vector

```{r}
x <- vector(length = 10)
x <- vector("numeric", 10)
x <- vector("list", 10)
```

### Matrices

```{r}
x <- matrix(sample(seq(1000), 30), nrow = 10, ncol = 3)
x
class(x)
```

#### Construct by row or by column

By default, vectors are constructed by column (byrow = FALSE)

```{r}
x <- matrix(1:20, nrow = 10, ncol = 2, byrow = FALSE)
x
```

```{r}
x <- matrix(1:20, nrow = 10, ncol = 2, byrow = TRUE)
x
```

#### Initialize a matrix

```{r}
(x <- matrix(NA, nrow = 6, ncol = 4))
(x <- matrix(0, nrow = 6, ncol = 4))
```

#### Bind vectors by column or by row

```{r}
x <- cbind(1:10, 11:20, 41:50)
x
```

```{r}
x <- rbind(1:10, 11:20, 41:50)
x
```

### Lists

```{r}
x <- list(one = 1:4,
          two = sample(seq(0, 100, .1), 10),
          three = c("mango", "banana", "tangerine"),
          four = median)
class(x)
str(x)
```

#### Initialize a list

```{r}
x <- vector("list", 4)
x
```

###  Data frames

```{block, type="Note"}
Always keep in mind that data frames are specialized lists.
```

```{r}
x <- data.frame(Feat_1 = 1:5,
                Feat_2 = rnorm(5),
                Feat_3 = paste0("rnd_", sample(seq(100), 5)))
x
class(x)
str(x)
class(x$Feat_1)
```

```{r}
mat <- matrix(1:100, 10)
length(mat)
df <- as.data.frame(mat)
length(df)
```

### Arrays

A 1D array is not a vector:

```{r}
x <- 1:10
xa <- array(1:10, dim = 10)
class(x)
is.vector(x)
class(xa)
is.vector(xa)
```

A 2D array is a matrix:

```{r}
x <- array(1:40, dim = c(10, 4))
class(x)
dim(x)
```

An ND array is an ND array (N-dimensional array):

```{r}
x <- array(sample(1:255, 432, TRUE), dim = c(12, 12, 3))
class(x)
```

```{r}
x <- array(sample(1:255, 432, TRUE), dim = c(12, 12, 3))
par("pty")
par(pty = "s")
plot(NULL, NULL,
     xlim = c(0, 100), ylim = c(0, 100),
     axes = F, ann = F, pty = "s")
rasterImage(x/255, 0, 0, 100, 100)
```

```{r}
n4 <- array(sample(1:255, 600, TRUE), dim = c(10, 4, 3, 5))
```

### Factors

Factors are used to store categorical data and they have many important uses in statistics and data science.

```{r}
(x <- factor(c("a", "b", "c", "d", "a", "a", "d", "c")))
```

```{block, type="Note"}
In R, a factor is stored as vector of integers indexing a set of levels.
```

`str` of a factor outputs:

* the number of levels
* the levels, in order
* the vector as an integer index of the levels

```{r}
str(x)
```

You can define the levels and their order using the `levels` argument in `factor()`. If undefined, the levels will be set to the unique values of the input vector sorted alphabetically.  
In many cases we want to define levels in a specific order.

```{r}
(x <- factor(c("alpha", "alpha", "beta", "delta", "delta")))
table(x)
(x <- factor(c("alpha", "alpha", "beta", "delta", "delta"),
            levels = c("alpha", "beta", "gamma", "delta")))
class(x)
table(x)
```

```{r}
levels(x)
```

```{block, type="Note"}
Setting new levels with `levels` *changes all values*
```

```{r}
xe <- x
levels(xe) <- c("a", "b", "c", "d")
xe
```

You can change the order of the levels, without changing the values:

```{r}
xr <- factor(as.character(x), levels = c("delta", "gamma", "beta", "alpha"))
xr
```

#### Factors can be ordered

The order of a factor's levels affects their internal integer representation. 
This, in turn, affects their order in some application (like plotting categorical variables in ggplot2).  

An **ordered factor** is a separate concept, where you are defining that there is a meaningful order, often quantitative, to the levels - like "low, mid, high", or "grade 1", "grade 2", "grade 3", "grade 4".

```{r}
x <- factor(c("low", "low", "high", "low", "mid", 
              "mid", "high", "low", "high", "mid"),
            levels = c("low", "mid", "high"),
            ordered = TRUE)
x
class(x)
```


## Attributes

R objects may have some builtin attributes but you can add arbitrary attributes to any R objects. These are used to store additional information, sometimes called metadata, about an object.  

### Read attributes

To read an object's attributes, use `attributes`:

```{r}
attributes(iris)
```

This returns a named list. In this case we got names, class, and row.names of the iris data frame.  

### Add attributes

You can assign new attributes using `attr`:

```{r}
(x <- c(1:10))
attr(x, "name") <- "Very special vector"
```

Printing the vector after adding a new attribute, prints the attribute name and value underneath the vector itself:

```{r}
x
```

Our trusty `str` function will print attributes as well

```{r}
str(x)
```

### Common builtin attributes

Vectors can have named elements. A new vector has no names, but you can add them:

```{r}
x <- rnorm(10)
names(x)
names(x) <- paste0("Value", seq(x))
x
```

Matrices and data frames can have column names (`colnames`) and row names (`rownames`):

```{r}
x <- matrix(1:15, 5)
colnames(x)
rownames(x)
colnames(x) <- paste0("Feature", seq(3))
rownames(x) <- paste0("Case", seq(5))
x
```

Lists are vectors so they have `names`. These can be defined when a list is created using the name-value pairs or added/changed at any time.

```{r}
x <- list(HospitalName = "CaliforniaGeneral",
          ParticipatingDepartments = c("Neurology", "Psychiatry", "Neurosurgery"),
          PatientIDs = 1001:1253)
names(x)
```

Add/Change names:

```{r}
names(x) <- c("Hospital", "Departments", "PIDs")
x
```

Remember that data a frame is a special type of list. Therefore in data frames `colnames` and `names` are equivalent:

```{r}
colnames(iris)
names(iris)
```

Note: As we saw, matrices have `colnames` and `rownames.` Using `names` on a matrix will assign names to *individual elements*, as if it was a long vector - this is not usually very useful.