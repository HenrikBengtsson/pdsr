# Working with data frames {#dataframeops}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 5, fig.height = 5,
                      comment = NA, cache = TRUE)
```

R's data.frame is the main object used to hold data for statistical analysis, visualization, and predictive modeling.

See the [Data frames](#dataframes) section in the [Data Structures](#structures) chapter for basic info on data.frames.

## Column and row names

Let's start with a simple example data.frame:

```{r}
df <- data.frame(PID = c(111:119),
                 Hospital = c("UCSF", "HUP", "Stanford",
                             "Stanford", "UCSF", "HUP", 
                             "HUP", "Stanford", "UCSF"),
                Age = c(22, 34, 41, 19, 53, 21, 63, 22, 19),
                Sex = c(1, 1, 0, 1, 0, 0, 1, 0, 0),
                row.names = "PID")
```

We can get column names and row names with `colnames()` and `rownames()`, respectively:

```{r}
colnames(df)
rownames(df)
```

To set new column or row names use the form:

`colnames(df) <- new.colnames` 

`rownames(df) <- new.rownames` 

where `new.colnames` and `new.rownames` is a character vector.

You can rename all columns/rows or use indexing to replace specific names:

Rename all rows:

```{r}
rownames(df) <- paste0("Patient_", 1:9)
df
```

Rename first two columns:

```{r}
colnames(df)[1:2] <- c("Center", "Age_at_Dx")
df
```

## Delete columns or rows

To delete a data.frame column, set it to [NULL](#replacing-with-null):

```{r}
df$Sex <- NULL
df
```

To delete a data.frame row, you can "index it out".  

For example, to remove the third and fifths rows of the above data.frame using an integer index:

```{r}
df <- df[-c(3, 5), ]
df
```

You can similarly exclude a row using a logical index. Logical indexing occurs usually following some filtering condition. 

For example, exclude patients under 20 years old:

```{r}
df <- df[!df$Age < 20, ]
df
```

## Table Joins (i.e. Merging data.frames) {#tablejoins}

We often have data from separate sources that we want to combine into a single data.frame. Table joins allow you to specify how to perform such a merge.

Scenario: You have received two tables with clinical data. Each table contains a column with a unique identifier (ID) plus a number of variables which are unique to each table. You want to merge them into one big table so that for each ID you have all available variables. You want to make sure that the same ID number (e.g. 108) corresponds to the same case in both datasets, but not all IDs needs to be present in both datasets.

Let's make up some synthetic data:

```{r}
a <- data.frame(PID = c(101:109),
                Hospital = c("UCSF", "HUP", "Stanford",
                             "Stanford", "UCSF", "HUP", 
                             "HUP", "Stanford", "UCSF"),
                Age = c(22, 34, 41, 19, 53, 21, 63, 22, 19),
                Sex = c(1, 1, 0, 1, 0, 0, 1, 0, 0))

b  <- data.frame(PID = c(106:112),
                 V1 = c(153, 89, 112, 228,  91, 190, 101),
                 Department = c("Neurology", "Radiology",
                                "Emergency", "Cardiology",
                                "Surgery", "Neurology", "Psychiatry"))
a
b
dim(a)
dim(b)
```

There are four main types of join operations:

```{r, echo = FALSE, out.width = "100%", fig.align = "center", fig.cap = "Common Join Operations"}
knitr::include_graphics("R_joins.png")
```

### Inner join

The default arguments of `merge()` perform an **inner join**:

```{r}
(ab.inner <- merge(a, b))
# same as
(ab.inner <- merge(a, b, by = "PID"))
# same as
(ab.inner <- merge(a, b, all = FALSE))
```

Note that the resulting table only contains ***cases found in both datasets***, i.e. IDs 106 through 109

### Outer join

You can perform an **outer join** by specifying `all = TRUE`:

```{r}
(ab.outer <- merge(a, b, all = TRUE))
(ab.outer <- merge(a, b, by = "PID", all = TRUE))
```

Note that the resulting data frame contains ***all cases found in either dataset*** and missing values are represented with `NA`.

### Left outer join

You can perform a **left outer join** by specifying `all.x = TRUE`:

```{r}
(ab.leftOuter <- merge(a, b, all.x = TRUE))
```

Note that the resulting data frame contains ***all cases present in the left input dataset*** (i.e. the one defined first in the arguments) only. 

### Right outer join

You can perform a **right outer join** by specifying `all.y = TRUE`:

```{r}
(ab.rightOuter <- merge(a, b, all.y = TRUE))
```

Note how the resulting data frame contains ***all cases present in the right input dataset*** (i.e. the one defined seecond in the arguments) only.

## Wide to Long

```{r wideLong, echo = FALSE, out.width = "100%", fig.align = "center", fig.cap = "Wide and Long data format example. Take a moment to notice how the wide table on the left with 3 cases (3 IDs) and 3 variables gets converted from a 3 x 4 table to a 9 x 3 long table on the right. The values (outlined in magenta) are present once in each table: on the wide table they form an **ID x Variable** matrix, while on the long they are stacked on a **single column**. The IDs have to be repeated on the long table, once for each variable and there is a new 'Variable' column to provide the information present in the wide table's column names." }
knitr::include_graphics("wide_long.png", dpi = NA)
```

A wide dataset contains only a single row per case (e.g. patient), while a long dataset can contain multiple rows per case (e.g. for multiple timepoints). We want to be able to convert from one format to the other because different programs (e.g. statistical models, visualization) may expect data in one of the other format for different applications (e.g. longitudinal modeling or grouped visualizations).

```{r}
library(tidyr)
library(data.table)
```

Let's create an example data frame:

```{r}
(dat_wide <- data.frame(ID = c(1, 2, 3),
                       mango = c(1.1, 2.1, 3.1),
                       banana = c(1.2, 2.2, 3.2),
                       tangerine = c(1.3, 2.3, 3.3)))
```

### base

The `reshape()` function is probably one of the more complicated because the documentation is not entirely clear, especially if you're not used to the jargon and specifically with regards to which arguments refer to the input vs. output data frame. Use the following figure as a guide to understand `reshape()`'s syntax. You can use it as a reference when building your own `reshape()` command by following steps 1 through 5:

```{r wideLongSyntax, echo = FALSE, out.width = "100%", fig.align = "center", fig.cap = "`reshape()` syntax for Wide to Long transformation."}
knitr::include_graphics("R_reshape_wide2long.png", dpi = NA)
```

```{r}
dat_wide2long <- reshape(# Data in wide format
                         data = dat_wide,
                         # The column name that defines case ID
                         idvar = "ID",
                         # The columns whose values we want to keep
                         varying = list(2:4),
                         # The name of the new column which will contain all 
                         # the values from the columns above
                         v.names = "Score",
                         # The values/names, of length = (N columns in "varying"), 
                         #that will be recycled to indicate which column from the 
                         #wide dataset each row corresponds to
                         times = c(colnames(dat_wide)[2:4]),
                         # The name of the new column created to hold the values 
                         # defined by "times"
                         timevar = "Fruit",                  
                         direction = "long") 
```

You can also define `varying` with a character vector:

`varying = list(c("mango", "banana","tangerine")`  

Explore the resulting data frame's attributes:

```{r}
attributes(dat_wide2long)
```

These attributes are present if and only if a long data set was created from a wide as above. In that case, reshaping back to a wide data frame is as easy as:

```{r}
reshape(dat_wide2long)
```

### tidyr

```{r}
dat_wide2long_tv <- pivot_longer(dat_wide,
                           cols = 2:4,
                           names_to = "Fruit",
                           values_to = "Score")
dat_wide2long_tv
```

### data.table

```{r}
dat_wide_dt <- as.data.table(dat_wide)
dat_wide2long_dt <- melt(dat_wide_dt,
                         id.vars = 1,
                         measure.vars = 2:4,
                         variable.name = "Fruit",
                         value.name = "Score")
setorder(dat_wide2long_dt, "ID")
dat_wide2long_dt
```

## Long to Wide

Let's create a long dataset:

```{r}
(dat_long <- data.frame(ID = c(1, 2, 3, 1, 2, 3, 1, 2, 3),
                       Fruit = c("mango", "mango", "mango", 
                                 "banana", "banana", "banana", 
                                 "tangerine", "tangerine", "tangerine"),
                       Score = c(1.1, 2.1, 3.1, 1.2, 2.2, 3.2, 1.3, 2.3, 3.3)))
```

### base

Using base `reshape()` for long-to-wide transformation is simpler than wide-to-long:

```{r longWideSyntax, echo = FALSE, out.width = "100%", fig.align = "center", fig.cap = "`reshape()` syntax for Long to Wide transformation."}
knitr::include_graphics("R_reshape_long2wide.png", dpi = NA)
```

```{r}
dat_long2wide <- reshape(dat_long,
                         idvar = "ID",
                         timevar = "Fruit",
                         v.names = "Score",
                         direction = "wide")
# Optionally rename columns
colnames(dat_long2wide) <- gsub("Score.", "", colnames(dat_long2wide))
dat_long2wide
```

### tidyr

```{r}
dat_long2wide_tv <- pivot_wider(dat_long,
                                id_cols = "ID",
                                names_from = "Fruit",
                                values_from = "Score")
dat_long2wide_tv
```

### data.table

`data.table`'s long to wide procedure is defined with a convenient formula notation:

```{r}
dat_long_dt <- as.data.table(dat_long)
dat_long2wide_dt <- dcast(dat_long_dt,
                          ID ~ Fruit,
                          value.var = "Score")
dat_long2wide_dt
```

## `subset()`

`subset()` allows you to filter cases that meet certain conditions using the `subset` argument, and optionally also select columns using the `select` argument:  

(`head()` returns the first few lines of a data frame. We use it to avoid printing too many lines)

```{r}
head(iris)
iris_sl.gt.med <- subset(iris, Sepal.Length > median(Sepal.Length))
```

Note: You can use the column name Sepal.Length directly, i.e. unquoted and you don't need to use `iris$Sepal.Length`. This is called Non-Standard Evaluation (NSE).

```{r}
x <- data.frame(one = 1:10,
                two = rnorm(10),
                group = c(rep("alpha", 4),  rep("beta", 6)))
subset(x, subset = two > 0, select = two)
subset(x, two > 0, -one)
subset(x, two > 0, two:one)
subset(x, two > 0, two:group)
```

## `split()`

Split a data frame into multiple data frames by groups defined by a factor:

```{r}
x_by_group <- split(x, x$group)
```

## `with()`

Within a `with()` expression, you can access data.frame columns without quoting or using the `$` operator:

```{r}
with(x, x[group == "alpha", ])
with(x, x[two > 0, ])
```

## Feature transformation with `transform()`

Make up some data:

```{r}
dat <- data.frame(Sex = c(0, 0, 1, 1, 0),
                  Height = c(1.5, 1.6, 1.55, 1.73, 1.8),
                  Weight = c(55, 70, 69, 76, 91))
```

```{r}
dat <- transform(dat, BMI = Weight/Height^2)
dat
```

`transform()` is probably not used too often, because it is trivial to do the same with direct assignment:

```{r}
dat$BMI <- dat$Weight/dat$Height^2
```

but can be useful when adding multiple variables and/or used in a [pipe](#pipe):

```{r}
library(magrittr)
dat %>% 
  subset(Sex == 0) %>%
  transform(DeltaWeightFromMean = Weight - mean(Weight),
            BMI = Weight/Height^2,
            CI = Weight/Height^3)
```
