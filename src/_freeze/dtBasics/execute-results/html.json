{
  "hash": "88e015f399b02dc735af50f9acd965e0",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk:\n    comment: \"\"\n---\n\n# Efficient Data Analysis with **data.table** {#sec-datatable}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![data.table significantly enhances the base R data.frame](R_data.table.png){#fig-datatable fig-align='center' width=50%}\n:::\n:::\n\n\n## `data.table` extends the power of `data.frame`\n\nSome of the ways in which a `data.table` differs from a `data.frame`:  \n\n- A lot more than indexing can be done within a `data.table`'s \"frame\" (`dt[i, j, by]`):\nfilter, select & operate on columns, group-by operations\n- Access column names directly without quoting\n- Many operations can be performed ***\"in-place\"*** (i.e. with no assignment)\n- Working on big data within a `data.table` can be orders of magnitude faster.\n\n`data.table` operations remain as close as possible to `data.frame` operations, \ntrying to extend rather than replace the latter's functionality.\n\n**data.table** includes thorough and helpful error messages that often point to \na solution. This includes common mistakes new users may make when trying \ncommands that would work on a `data.frame`\nbut are different on a `data.table`.\n\n### Load the `data.table` package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n```\n:::\n\n\n## Create a `data.table`\n\n### By assignment: `data.table()`\n\nLet's create a `data.frame` and a `data.table` to explore side by side.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(A = 1:5,\n                 B = c(1.2, 4.3, 9.7, 5.6, 8.1),\n                 C = c(\"a\", \"b\", \"b\", \"a\", \"a\"))\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B C\n1 1 1.2 a\n2 2 4.3 b\n3 3 9.7 b\n4 4 5.6 a\n5 5 8.1 a\n```\n:::\n:::\n\n\n`data.table()` syntax is similar to `data.frame()` (differs in some arguments)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- data.table(A = 1:5,\n                 B = c(1.2, 4.3, 9.7, 5.6, 8.1),\n                 C = c(\"a\", \"b\", \"b\", \"a\", \"a\"))\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   A   B C\n1: 1 1.2 a\n2: 2 4.3 b\n3: 3 9.7 b\n4: 4 5.6 a\n5: 5 8.1 a\n```\n:::\n\n```{.r .cell-code}\nclass(dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.table\" \"data.frame\"\n```\n:::\n:::\n\n\nNotice how a `data.table` object also inherits from `data.frame`. This means \nthat if a method does not exist for `data.table`, the method for `data.frame` \nwill be used - review [classes and generic functions](#classes).\n<br><br>\nAs part of improving efficiency, data.tables do away with row names. Instead of \nusing rownames, you can and should add an extra column (e.g. \"ID\") with the \nsame information - this is advisable when working with data.frames as well.\n<br><br>\nA rather convenient option is to have data.tables print each column's class \nbelow the column name. You can pass the argument `class = TRUE` to `print()` or \nset the global option `datatable.print.class` using `options()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(datatable.print.class = TRUE)\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <char>\n1:     1   1.2      a\n2:     2   4.3      b\n3:     3   9.7      b\n4:     4   5.6      a\n5:     5   8.1      a\n```\n:::\n:::\n\n\nSame as with a data.frame, to automatically convert strings to factors, you can \nuse the `stringsAsFactors` argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- data.table(A = 1:5,\n                 B = c(1.2, 4.3, 9.7, 5.6, 8.1),\n                 C = c(\"a\", \"b\", \"b\", \"a\", \"a\"),\n                 stringsAsFactors = TRUE)\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     1   1.2      a\n2:     2   4.3      b\n3:     3   9.7      b\n4:     4   5.6      a\n5:     5   8.1      a\n```\n:::\n:::\n\n\n### By coercion: `as.data.table()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(A = 1:5,\n                  B = c(1.2, 4.3, 9.7, 5.6, 8.1),\n                  C = c(\"a\", \"b\", \"b\", \"a\", \"a\"),\n                  stringsAsFactors = TRUE)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B C\n1 1 1.2 a\n2 2 4.3 b\n3 3 9.7 b\n4 4 5.6 a\n5 5 8.1 a\n```\n:::\n\n```{.r .cell-code}\ndat2 <- as.data.table(dat)\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     1   1.2      a\n2:     2   4.3      b\n3:     3   9.7      b\n4:     4   5.6      a\n5:     5   8.1      a\n```\n:::\n:::\n\n\n### By coercion ***in-place***: `setDT()`\n\n`setDT()` converts a list or data.frame into a `data.table` ***in-place***. This means\nthe object passed to `setDT()` is changed and you do not need to assign the output to a \nnew object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(A = 1:5,\n                  B = c(1.2, 4.3, 9.7, 5.6, 8.1),\n                  C = c(\"a\", \"b\", \"b\", \"a\", \"a\"))\nclass(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsetDT(dat)\nclass(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.table\" \"data.frame\"\n```\n:::\n:::\n\n\nYou can similarly convert a `data.table` to a `data.frame`, in-place:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetDF(dat)\nclass(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\n## Display `data.table` structure with `str()`\n\n`str()` works the same (and you should keep using it!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5 obs. of  3 variables:\n $ A: int  1 2 3 4 5\n $ B: num  1.2 4.3 9.7 5.6 8.1\n $ C: chr  \"a\" \"b\" \"b\" \"a\" ...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClasses 'data.table' and 'data.frame':\t5 obs. of  3 variables:\n $ A: int  1 2 3 4 5\n $ B: num  1.2 4.3 9.7 5.6 8.1\n $ C: Factor w/ 2 levels \"a\",\"b\": 1 2 2 1 1\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n:::\n:::\n\n\n## Combine `data.table`s\n\n`cbind()` and `rbind()` work on `data.table`s the same as on `data.frame`s:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt1 <- data.table(a = 1:5)\ndt2 <- data.table(b = 11:15)\ncbind(dt1, dt2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       a     b\n   <int> <int>\n1:     1    11\n2:     2    12\n3:     3    13\n4:     4    14\n5:     5    15\n```\n:::\n\n```{.r .cell-code}\nrbind(dt1, dt1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        a\n    <int>\n 1:     1\n 2:     2\n 3:     3\n 4:     4\n 5:     5\n 6:     1\n 7:     2\n 8:     3\n 9:     4\n10:     5\n```\n:::\n:::\n\n\n## Set column names ***in-place***\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndta <- data.table(\n  ID = sample(8000:9000, size = 10),\n  A = rnorm(10, mean = 47, sd = 8),\n  W = rnorm(10, mean = 87, sd = 7)\n)\ndta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       ID        A         W\n    <int>    <num>     <num>\n 1:  8439 43.76326  97.05947\n 2:  8699 50.62270  86.53151\n 3:  8851 71.69495 100.45128\n 4:  8498 42.87227  83.48540\n 5:  8140 57.60923  90.92345\n 6:  8319 50.69327  81.70024\n 7:  8168 47.21509  81.33416\n 8:  8315 43.72839  92.55674\n 9:  8681 40.42497  90.57055\n10:  8940 45.45886  93.19332\n```\n:::\n:::\n\nUse the syntax:\n\n`setnames(dt, old, new)`\n\nto change the column names of a data.table in-place.\n\nChanges all column names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetnames(dta, names(dta), c(\"Patient_ID\", \"Age\", \"Weight\"))\ndta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Patient_ID      Age    Weight\n         <int>    <num>     <num>\n 1:       8439 43.76326  97.05947\n 2:       8699 50.62270  86.53151\n 3:       8851 71.69495 100.45128\n 4:       8498 42.87227  83.48540\n 5:       8140 57.60923  90.92345\n 6:       8319 50.69327  81.70024\n 7:       8168 47.21509  81.33416\n 8:       8315 43.72839  92.55674\n 9:       8681 40.42497  90.57055\n10:       8940 45.45886  93.19332\n```\n:::\n:::\n\n\nChange subset of names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold_names <- c(\"Age\", \"Weight\")\nsetnames(dta, old_names, paste0(old_names, \"_at_Admission\"))\ndta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Patient_ID Age_at_Admission Weight_at_Admission\n         <int>            <num>               <num>\n 1:       8439         43.76326            97.05947\n 2:       8699         50.62270            86.53151\n 3:       8851         71.69495           100.45128\n 4:       8498         42.87227            83.48540\n 5:       8140         57.60923            90.92345\n 6:       8319         50.69327            81.70024\n 7:       8168         47.21509            81.33416\n 8:       8315         43.72839            92.55674\n 9:       8681         40.42497            90.57055\n10:       8940         45.45886            93.19332\n```\n:::\n:::\n\n\n`old` argument can also be integer index of column(s).\n\nFor example, change the name of the first column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetnames(dta, 1, \"Hospital_ID\")\ndta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Hospital_ID Age_at_Admission Weight_at_Admission\n          <int>            <num>               <num>\n 1:        8439         43.76326            97.05947\n 2:        8699         50.62270            86.53151\n 3:        8851         71.69495           100.45128\n 4:        8498         42.87227            83.48540\n 5:        8140         57.60923            90.92345\n 6:        8319         50.69327            81.70024\n 7:        8168         47.21509            81.33416\n 8:        8315         43.72839            92.55674\n 9:        8681         40.42497            90.57055\n10:        8940         45.45886            93.19332\n```\n:::\n:::\n\n\n## Filter rows\n\nThere are many similarities and some notable differences in how indexing works \nin a `data.table` vs. a `data.frame`.\n\nFiltering rows with an integer or logical index is largely the same in a \n`data.frame` and a `data.table`, but in a `data.table` you can omit the comma \nto select all columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[c(1, 3, 5), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B C\n1 1 1.2 a\n3 3 9.7 b\n5 5 8.1 a\n```\n:::\n\n```{.r .cell-code}\ndt[c(1, 3, 5), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     1   1.2      a\n2:     3   9.7      b\n3:     5   8.1      a\n```\n:::\n\n```{.r .cell-code}\ndt[c(1, 3, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     1   1.2      a\n2:     3   9.7      b\n3:     5   8.1      a\n```\n:::\n:::\n\n\nUsing a variable that holds a row index, whether integer or logical:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowid <- c(1, 3, 5)\ndf[rowid, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B C\n1 1 1.2 a\n3 3 9.7 b\n5 5 8.1 a\n```\n:::\n\n```{.r .cell-code}\ndt[rowid, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     1   1.2      a\n2:     3   9.7      b\n3:     5   8.1      a\n```\n:::\n\n```{.r .cell-code}\ndt[rowid]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     1   1.2      a\n2:     3   9.7      b\n3:     5   8.1      a\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrowbn <- c(T, F, T, F, T)\ndf[rowbn, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B C\n1 1 1.2 a\n3 3 9.7 b\n5 5 8.1 a\n```\n:::\n\n```{.r .cell-code}\ndt[rowbn, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     1   1.2      a\n2:     3   9.7      b\n3:     5   8.1      a\n```\n:::\n\n```{.r .cell-code}\ndt[rowbn]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     1   1.2      a\n2:     3   9.7      b\n3:     5   8.1      a\n```\n:::\n:::\n\n\n### Conditional filtering\n\nAs a reminder, there are a few ways to conditionally filter cases in a data.frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[df$A > mean(df$A) & df$B > mean(df$B), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B C\n5 5 8.1 a\n```\n:::\n\n```{.r .cell-code}\nsubset(df, A > mean(A) & B > mean(B))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B C\n5 5 8.1 a\n```\n:::\n\n```{.r .cell-code}\nwith(df, df[A > mean(A) & B > mean(B), ])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B C\n5 5 8.1 a\n```\n:::\n:::\n\n\n`data.table` allows you to refer to column names directly and unquoted, which \nmakes writing filter conditions easier/more compact:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[A > mean(A) & B > mean(B)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     5   8.1      a\n```\n:::\n:::\n\n\nThe `data.table` package also includes an S3 method for `subset()` that works \nthe same way as with a `data.frame`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(dt, A > mean(A) & B > mean(B))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C\n   <int> <num> <fctr>\n1:     5   8.1      a\n```\n:::\n:::\n\n\nAs another example, exclude cases base on missingness in a specific column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadf <- as.data.frame(sapply(1:5, function(i) rnorm(10)))\nadf |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           V1         V2         V3         V4         V5\n1 -1.24761346  0.4025497  0.2143494  2.7176153 -0.6905734\n2  0.66847200 -0.4427266  0.9676509  2.2046212 -0.7021980\n3 -0.71014956  1.7005733  0.8626301  0.6632499  0.4791712\n4 -0.04508463  1.5573271 -1.3853067  0.1763581  0.3470066\n5 -0.15476364  1.4209189 -0.0610568 -1.5852660 -1.7277485\n6 -0.60980078 -1.3972905 -0.9974748 -0.1246307 -0.5155726\n```\n:::\n\n```{.r .cell-code}\nadf[1, 3] <- adf[3, 4] <- adf[5, 3] <- adf[7, 3] <- NA\nadt <- as.data.table(adf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadf[!is.na(adf$V3), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            V1         V2         V3         V4         V5\n2   0.66847200 -0.4427266  0.9676509  2.2046212 -0.7021980\n3  -0.71014956  1.7005733  0.8626301         NA  0.4791712\n4  -0.04508463  1.5573271 -1.3853067  0.1763581  0.3470066\n6  -0.60980078 -1.3972905 -0.9974748 -0.1246307 -0.5155726\n8  -0.18925444  0.3292909  0.4876072  0.1910224  1.4100760\n9  -0.25436553 -0.0979308 -0.3416780  1.8682281 -0.4689900\n10  0.17781145 -0.2188904 -1.5097725 -0.4801169  0.4573402\n```\n:::\n\n```{.r .cell-code}\nadt[!is.na(V3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            V1         V2         V3         V4         V5\n         <num>      <num>      <num>      <num>      <num>\n1:  0.66847200 -0.4427266  0.9676509  2.2046212 -0.7021980\n2: -0.71014956  1.7005733  0.8626301         NA  0.4791712\n3: -0.04508463  1.5573271 -1.3853067  0.1763581  0.3470066\n4: -0.60980078 -1.3972905 -0.9974748 -0.1246307 -0.5155726\n5: -0.18925444  0.3292909  0.4876072  0.1910224  1.4100760\n6: -0.25436553 -0.0979308 -0.3416780  1.8682281 -0.4689900\n7:  0.17781145 -0.2188904 -1.5097725 -0.4801169  0.4573402\n```\n:::\n:::\n\n\n## Select columns\n\n### By position(s)\n\nSelecting a single column in `data.table` does not drop to a vector, similar to \nusing `drop = FALSE` in a data.frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\ndf[, 1, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A\n1 1\n2 2\n3 3\n4 4\n5 5\n```\n:::\n\n```{.r .cell-code}\ndt[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A\n   <int>\n1:     1\n2:     2\n3:     3\n4:     4\n5:     5\n```\n:::\n:::\n\n\nDouble bracket indexing of a single column works the same on a `data.frame` and \na `data.table`, returning a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.2 4.3 9.7 5.6 8.1\n```\n:::\n\n```{.r .cell-code}\ndt[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.2 4.3 9.7 5.6 8.1\n```\n:::\n:::\n\nA vector of column positions returns a smaller `data.table`, similar to how it \nreturns a smaller `data.frame` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[, c(1, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B\n1 1 1.2\n2 2 4.3\n3 3 9.7\n4 4 5.6\n5 5 8.1\n```\n:::\n\n```{.r .cell-code}\ndt[, c(1, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B\n   <int> <num>\n1:     1   1.2\n2:     2   4.3\n3:     3   9.7\n4:     4   5.6\n5:     5   8.1\n```\n:::\n:::\n\n\n### By name(s)\n\nIn `data.table`, you access column names directly without quoting or using the \n`$` notation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[, \"B\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.2 4.3 9.7 5.6 8.1\n```\n:::\n\n```{.r .cell-code}\ndf$B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.2 4.3 9.7 5.6 8.1\n```\n:::\n\n```{.r .cell-code}\ndt[, B]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.2 4.3 9.7 5.6 8.1\n```\n:::\n:::\n\n\nBecause of this, `data.table` requires a slightly different syntax to use \na variable as a column index which can contain integer positions, logical \nindex, or column names. While on a data.frame you can do pass an index vector directly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolid <- c(1, 2)\ncolbn <- c(FALSE, TRUE, TRUE)\ncolnm <- c(\"A\", \"C\")\ndf[, colid]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A   B\n1 1 1.2\n2 2 4.3\n3 3 9.7\n4 4 5.6\n5 5 8.1\n```\n:::\n\n```{.r .cell-code}\ndf[, colbn]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    B C\n1 1.2 a\n2 4.3 b\n3 9.7 b\n4 5.6 a\n5 8.1 a\n```\n:::\n\n```{.r .cell-code}\ndf[, colnm]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A C\n1 1 a\n2 2 b\n3 3 b\n4 4 a\n5 5 a\n```\n:::\n:::\n\n\nTo do the same in a `data.table`, you must prefix the index vector with two dots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, ..colid]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B\n   <int> <num>\n1:     1   1.2\n2:     2   4.3\n3:     3   9.7\n4:     4   5.6\n5:     5   8.1\n```\n:::\n\n```{.r .cell-code}\ndt[, ..colbn]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       B      C\n   <num> <fctr>\n1:   1.2      a\n2:   4.3      b\n3:   9.7      b\n4:   5.6      a\n5:   8.1      a\n```\n:::\n\n```{.r .cell-code}\ndt[, ..colnm]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A      C\n   <int> <fctr>\n1:     1      a\n2:     2      b\n3:     3      b\n4:     4      a\n5:     5      a\n```\n:::\n:::\n\n\nThink of working inside the `data.table` frame (i.e. within the \"[...]\") like \nan environment: you have direct access to the variables, i.e. columns within it. If you \nwant to refer to variables outside the `data.table`, you must prefix their names\nwith `..` (similar to how you access the directory above your current working \ndirectory in the system shell).\n<br><br>\n\nSelecting a single column by name returns a **vector**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, A]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nSelecting one or more columns by name enclosed in `list()` or `.()` (which, in \nthis case, is short for `list()`), always returns a **`data.table`**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, .(A)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A\n   <int>\n1:     1\n2:     2\n3:     3\n4:     4\n5:     5\n```\n:::\n\n```{.r .cell-code}\ndt[, .(A, B)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B\n   <int> <num>\n1:     1   1.2\n2:     2   4.3\n3:     3   9.7\n4:     4   5.6\n5:     5   8.1\n```\n:::\n:::\n\n\n### `.SD` & `.SDcols`\n\n`.SDcols` is a special symbol that can be used to select columns of a data.table \nas an alternative to `j`. It can accept a vector of integer positions or column names.\n`.SD` is another special symbol that can be used in `j` and refers to either the entire \ndata.table, or the subset defined by `.SDcols`, if present. The following can be used to\nselect columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, .SD, .SDcols = colid]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B\n   <int> <num>\n1:     1   1.2\n2:     2   4.3\n3:     3   9.7\n4:     4   5.6\n5:     5   8.1\n```\n:::\n:::\n\n\nOne of the main uses of .SD is shown below in combination with `lapply()`.\n\n## Add new column ***in-place***\n\nUse `:=` assignment to add a new column in the existing `data.table`.\nIn-place assignment means you do not have to assign the result to a variable, \nthe existing `data.table` will be modified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, AplusB := A + B]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C AplusB\n   <int> <num> <fctr>  <num>\n1:     1   1.2      a    2.2\n2:     2   4.3      b    6.3\n3:     3   9.7      b   12.7\n4:     4   5.6      a    9.6\n5:     5   8.1      a   13.1\n```\n:::\n:::\n\n\nNote how `dt` was modified even though we did not run \n`dt <- dt[, AplusB := A + B]`\n\n## Add multiple columns ***in-place***\n\nYou can define multiple new column names using a character vector of new column \nnames on the left of `:=` and a list on the right.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, c(\"AtimesB\", \"AoverB\") := list(A*B, A/B)]\n```\n:::\n\n\nWe can use `lapply()` since it always returns a list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvnames <- c(\"A\", \"B\")\ndt[, paste0(\"log\", vnames) := lapply(.SD, log), .SDcols = vnames]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C AplusB AtimesB    AoverB      logA      logB\n   <int> <num> <fctr>  <num>   <num>     <num>     <num>     <num>\n1:     1   1.2      a    2.2     1.2 0.8333333 0.0000000 0.1823216\n2:     2   4.3      b    6.3     8.6 0.4651163 0.6931472 1.4586150\n3:     3   9.7      b   12.7    29.1 0.3092784 1.0986123 2.2721259\n4:     4   5.6      a    9.6    22.4 0.7142857 1.3862944 1.7227666\n5:     5   8.1      a   13.1    40.5 0.6172840 1.6094379 2.0918641\n```\n:::\n:::\n\n\nYou can also use `:=` in a little more awkward syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, `:=`(AminusB = A - B, AoverC = A / B)]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C AplusB AtimesB    AoverB      logA      logB AminusB\n   <int> <num> <fctr>  <num>   <num>     <num>     <num>     <num>   <num>\n1:     1   1.2      a    2.2     1.2 0.8333333 0.0000000 0.1823216    -0.2\n2:     2   4.3      b    6.3     8.6 0.4651163 0.6931472 1.4586150    -2.3\n3:     3   9.7      b   12.7    29.1 0.3092784 1.0986123 2.2721259    -6.7\n4:     4   5.6      a    9.6    22.4 0.7142857 1.3862944 1.7227666    -1.6\n5:     5   8.1      a   13.1    40.5 0.6172840 1.6094379 2.0918641    -3.1\n      AoverC\n       <num>\n1: 0.8333333\n2: 0.4651163\n3: 0.3092784\n4: 0.7142857\n5: 0.6172840\n```\n:::\n:::\n\n\n## Convert column type\n\n### Assignment by reference with `:=`\n\nUse any base R coercion function (`as.*`) to convert a column in-place using \nthe `:=` notation\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, A := as.numeric(A)]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C AplusB AtimesB    AoverB      logA      logB AminusB\n   <num> <num> <fctr>  <num>   <num>     <num>     <num>     <num>   <num>\n1:     1   1.2      a    2.2     1.2 0.8333333 0.0000000 0.1823216    -0.2\n2:     2   4.3      b    6.3     8.6 0.4651163 0.6931472 1.4586150    -2.3\n3:     3   9.7      b   12.7    29.1 0.3092784 1.0986123 2.2721259    -6.7\n4:     4   5.6      a    9.6    22.4 0.7142857 1.3862944 1.7227666    -1.6\n5:     5   8.1      a   13.1    40.5 0.6172840 1.6094379 2.0918641    -3.1\n      AoverC\n       <num>\n1: 0.8333333\n2: 0.4651163\n3: 0.3092784\n4: 0.7142857\n5: 0.6172840\n```\n:::\n:::\n\n\n### Delete columns in-place with `:=`\n\nTo delete a column, use `:=` to set it to NULL:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, AoverB := NULL]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C AplusB AtimesB      logA      logB AminusB    AoverC\n   <num> <num> <fctr>  <num>   <num>     <num>     <num>   <num>     <num>\n1:     1   1.2      a    2.2     1.2 0.0000000 0.1823216    -0.2 0.8333333\n2:     2   4.3      b    6.3     8.6 0.6931472 1.4586150    -2.3 0.4651163\n3:     3   9.7      b   12.7    29.1 1.0986123 2.2721259    -6.7 0.3092784\n4:     4   5.6      a    9.6    22.4 1.3862944 1.7227666    -1.6 0.7142857\n5:     5   8.1      a   13.1    40.5 1.6094379 2.0918641    -3.1 0.6172840\n```\n:::\n:::\n\n\nDelete multiple columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, c(\"logA\", \"logB\") := NULL]\n```\n:::\n\n\nOr:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, `:=`(AplusB = NULL, AminusB = NULL)]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B      C AtimesB    AoverC\n   <num> <num> <fctr>   <num>     <num>\n1:     1   1.2      a     1.2 0.8333333\n2:     2   4.3      b     8.6 0.4651163\n3:     3   9.7      b    29.1 0.3092784\n4:     4   5.6      a    22.4 0.7142857\n5:     5   8.1      a    40.5 0.6172840\n```\n:::\n:::\n\n\n### Fast loop-able assignment with `set()`\n\n`data.table`'s `set()` is a loop-able version of the `:=` operator. Use it in \na for loop to operate on multiple columns.\n\nSyntax: `set(dt, i, j, value)`\n\n* `dt` the data.table to operate on\n* `i` optionally define which rows to operate on. `i = NULL` to operate on all rows\n* `j` column names or index to be assigned `value`\n* `value` values to be assigned to `j` by reference\n\nAs a simple example, transform the first two columns in-place by squaring:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:2) {\n  set(dt, i = NULL, j = i, value = dt[[i]]^2)\n}\n```\n:::\n\n\n## Summarize\n\nYou can apply one or multiple summary functions on one or multiple columns.\nSurround the operations in `list()` or `.()` to output a *new* data.table \nholding the outputs of the operations, i.e. the input data.table remains unchanged.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_summary <- dt[, .(A_max = max(A), A_min = min(A), A_sd = sd(A))]\nA_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   A_max A_min    A_sd\n   <num> <num>   <num>\n1:    25     1 9.66954\n```\n:::\n:::\n\n\nExample: Get the standard deviation of all numeric columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumid <- sapply(dt, is.numeric)\ndt_mean <- dt[, lapply(.SD, sd), .SDcols = numid]\ndt_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         A        B  AtimesB    AoverC\n     <num>    <num>    <num>     <num>\n1: 9.66954 37.35521 15.74462 0.2060219\n```\n:::\n:::\n\n\nIf your function returns more than one value, the output will have multiple \nrows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_range <- dt[, lapply(.SD, range), .SDcols = numid]\ndt_range\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B AtimesB    AoverC\n   <num> <num>   <num>     <num>\n1:     1  1.44     1.2 0.3092784\n2:    25 94.09    40.5 0.8333333\n```\n:::\n:::\n\n\n## Set order\n\nYou can set the row order of a data.table in-place based on one or multiple columns'\nvalues using `setorder()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- data.table(PatientID = sample(1001:9999, size = 10),\n                 Height = rnorm(10, mean = 175, sd = 14),\n                 Weight = rnorm(10, mean = 78, sd = 10),\n                 Group = factor(sample(c(\"A\", \"B\"), size = 10, replace = TRUE)))\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    PatientID   Height   Weight  Group\n        <int>    <num>    <num> <fctr>\n 1:      2261 164.6924 66.78487      A\n 2:      8803 207.0957 79.07019      A\n 3:      3488 180.1401 62.99922      A\n 4:      8728 173.2521 81.19398      B\n 5:      4061 196.6994 79.21492      B\n 6:      9164 181.5995 69.70943      A\n 7:      2501 160.7419 92.12674      B\n 8:      2065 179.5793 67.28921      B\n 9:      7466 188.4470 96.45036      A\n10:      9801 179.1440 69.76589      B\n```\n:::\n:::\n\n\nLet's set the order by PatientID:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetorder(dt, PatientID)\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    PatientID   Height   Weight  Group\n        <int>    <num>    <num> <fctr>\n 1:      2065 179.5793 67.28921      B\n 2:      2261 164.6924 66.78487      A\n 3:      2501 160.7419 92.12674      B\n 4:      3488 180.1401 62.99922      A\n 5:      4061 196.6994 79.21492      B\n 6:      7466 188.4470 96.45036      A\n 7:      8728 173.2521 81.19398      B\n 8:      8803 207.0957 79.07019      A\n 9:      9164 181.5995 69.70943      A\n10:      9801 179.1440 69.76589      B\n```\n:::\n:::\n\n\nLet's re-order, always in-place, by group and then by height:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetorder(dt, Group, Height)\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    PatientID   Height   Weight  Group\n        <int>    <num>    <num> <fctr>\n 1:      2261 164.6924 66.78487      A\n 2:      3488 180.1401 62.99922      A\n 3:      9164 181.5995 69.70943      A\n 4:      7466 188.4470 96.45036      A\n 5:      8803 207.0957 79.07019      A\n 6:      2501 160.7419 92.12674      B\n 7:      8728 173.2521 81.19398      B\n 8:      9801 179.1440 69.76589      B\n 9:      2065 179.5793 67.28921      B\n10:      4061 196.6994 79.21492      B\n```\n:::\n:::\n\n\n## Group-by operations\n\nUp to now, we have learned how to use the `data.table` frame `dat[i, j]` to \nfilter cases in `i` or add/remove/transform columns in-place in `j`. \n`dat[i, j, by]` allows to perform operations separately on groups of cases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- data.table(A = 1:5,\n                 B = c(1.2, 4.3, 9.7, 5.6, 8.1),\n                 C = rnorm(5),\n                 Group = c(\"a\", \"b\", \"b\", \"a\", \"a\"))\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B          C  Group\n   <int> <num>      <num> <char>\n1:     1   1.2  0.2006163      a\n2:     2   4.3  1.4833122      b\n3:     3   9.7  0.2798987      b\n4:     4   5.6  0.7142420      a\n5:     5   8.1 -0.8266629      a\n```\n:::\n:::\n\n\n### Group-by summary\n\nAs we've seen, using `.()` or `list()` in `j`, returns a new `data.table`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, .(meanAbyGroup = mean(A)), by = Group]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Group meanAbyGroup\n   <char>        <num>\n1:      a     3.333333\n2:      b     2.500000\n```\n:::\n\n```{.r .cell-code}\ndt[, list(medianBbyGroup = median(B)), by = Group]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Group medianBbyGroup\n   <char>          <num>\n1:      a            5.6\n2:      b            7.0\n```\n:::\n:::\n\n\n### Group-by operation and assignment\n\nMaking an assignment with `:=` in `j`, adds a column in-place. If you combine such an\nassignment with a group-by operation, the same value will be assigned to all cases of the \ngroup:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, mean_A_by_Group := mean(A), by = Group]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B          C  Group mean_A_by_Group\n   <int> <num>      <num> <char>           <num>\n1:     1   1.2  0.2006163      a        3.333333\n2:     2   4.3  1.4833122      b        2.500000\n3:     3   9.7  0.2798987      b        2.500000\n4:     4   5.6  0.7142420      a        3.333333\n5:     5   8.1 -0.8266629      a        3.333333\n```\n:::\n:::\n\n\n## Apply functions to columns\n\nAny function that returns a list can be used in `j` to return a new \ndata.table - therefore lapply is perfect for getting summary on multiple \ncolumns. This is another example where you have to use the `.SD` notation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt1 <- as.data.table(sapply(1:3, \\(i) rnorm(10)))\ndt1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            V1         V2         V3\n         <num>      <num>      <num>\n 1:  0.7372506 -0.8721428 -0.1571351\n 2: -0.3452170 -1.6095156 -1.5539573\n 3:  1.6330658  0.3512571 -0.8862287\n 4: -1.9662455 -0.5955602  0.1608302\n 5: -1.6578826 -0.3923655 -0.4934351\n 6:  1.5004872  1.2072835  0.5309294\n 7:  0.8498987 -0.4717786  0.6721952\n 8: -1.0479133 -1.5420141  0.3035252\n 9: -1.8415118  0.6392715  0.2038257\n10: -0.4905052 -0.8130823  0.5182296\n```\n:::\n\n```{.r .cell-code}\nsetnames(dt1, names(dt1), c(\"Alpha\", \"Beta\", \"Gamma\"))\ndt1[, lapply(.SD, mean)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Alpha       Beta       Gamma\n        <num>      <num>       <num>\n1: -0.2628573 -0.4098647 -0.07012209\n```\n:::\n:::\n\n\nYou can specify which columns to operate on using the `.SDcols` argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt2 <- data.table(A = 1:5,\n                  B = c(1.2, 4.3, 9.7, 5.6, 8.1),\n                  C = rnorm(5),\n                  Group = c(\"a\", \"b\", \"b\", \"a\", \"a\"))\ndt2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B           C  Group\n   <int> <num>       <num> <char>\n1:     1   1.2 -0.53042899      a\n2:     2   4.3 -1.16499069      b\n3:     3   9.7  0.05566467      b\n4:     4   5.6 -1.41799649      a\n5:     5   8.1 -0.54054859      a\n```\n:::\n\n```{.r .cell-code}\ndt2[, lapply(.SD, mean), .SDcols = 1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B\n   <num> <num>\n1:     3  5.78\n```\n:::\n\n```{.r .cell-code}\n# same as\ndt2[, lapply(.SD, mean), .SDcols = c(\"A\", \"B\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B\n   <num> <num>\n1:     3  5.78\n```\n:::\n\n```{.r .cell-code}\ncols <- c(\"A\", \"B\")\ndt2[, lapply(.SD, mean), .SDcols = cols]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B\n   <num> <num>\n1:     3  5.78\n```\n:::\n:::\n\n\nYou can combine `.SDcols` and `by`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt2[, lapply(.SD, median), .SDcols = c(\"B\", \"C\"), by = Group]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Group     B          C\n   <char> <num>      <num>\n1:      a   5.6 -0.5405486\n2:      b   7.0 -0.5546630\n```\n:::\n:::\n\n\nCreate multiple new columns from transformation of existing and store with \ncustom prefix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Alpha       Beta      Gamma\n         <num>      <num>      <num>\n 1:  0.7372506 -0.8721428 -0.1571351\n 2: -0.3452170 -1.6095156 -1.5539573\n 3:  1.6330658  0.3512571 -0.8862287\n 4: -1.9662455 -0.5955602  0.1608302\n 5: -1.6578826 -0.3923655 -0.4934351\n 6:  1.5004872  1.2072835  0.5309294\n 7:  0.8498987 -0.4717786  0.6721952\n 8: -1.0479133 -1.5420141  0.3035252\n 9: -1.8415118  0.6392715  0.2038257\n10: -0.4905052 -0.8130823  0.5182296\n```\n:::\n\n```{.r .cell-code}\ndt1[, paste0(names(dt1), \"_abs\") := lapply(.SD, abs)]\ndt1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Alpha       Beta      Gamma Alpha_abs  Beta_abs Gamma_abs\n         <num>      <num>      <num>     <num>     <num>     <num>\n 1:  0.7372506 -0.8721428 -0.1571351 0.7372506 0.8721428 0.1571351\n 2: -0.3452170 -1.6095156 -1.5539573 0.3452170 1.6095156 1.5539573\n 3:  1.6330658  0.3512571 -0.8862287 1.6330658 0.3512571 0.8862287\n 4: -1.9662455 -0.5955602  0.1608302 1.9662455 0.5955602 0.1608302\n 5: -1.6578826 -0.3923655 -0.4934351 1.6578826 0.3923655 0.4934351\n 6:  1.5004872  1.2072835  0.5309294 1.5004872 1.2072835 0.5309294\n 7:  0.8498987 -0.4717786  0.6721952 0.8498987 0.4717786 0.6721952\n 8: -1.0479133 -1.5420141  0.3035252 1.0479133 1.5420141 0.3035252\n 9: -1.8415118  0.6392715  0.2038257 1.8415118 0.6392715 0.2038257\n10: -0.4905052 -0.8130823  0.5182296 0.4905052 0.8130823 0.5182296\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B           C  Group\n   <int> <num>       <num> <char>\n1:     1   1.2 -0.53042899      a\n2:     2   4.3 -1.16499069      b\n3:     3   9.7  0.05566467      b\n4:     4   5.6 -1.41799649      a\n5:     5   8.1 -0.54054859      a\n```\n:::\n\n```{.r .cell-code}\ncols <- c(\"A\", \"C\")\ndt2[, paste0(cols, \"_groupMean\") := lapply(.SD, mean), .SDcols = cols, by = Group]\ndt2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A     B           C  Group A_groupMean C_groupMean\n   <int> <num>       <num> <char>       <num>       <num>\n1:     1   1.2 -0.53042899      a    3.333333   -0.829658\n2:     2   4.3 -1.16499069      b    2.500000   -0.554663\n3:     3   9.7  0.05566467      b    2.500000   -0.554663\n4:     4   5.6 -1.41799649      a    3.333333   -0.829658\n5:     5   8.1 -0.54054859      a    3.333333   -0.829658\n```\n:::\n:::\n\n\n## Row-wise operations\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- data.table(a = 1:5, b = 11:15, c = 21:25, \n                 d = 31:35, e = 41:45)\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       a     b     c     d     e\n   <int> <int> <int> <int> <int>\n1:     1    11    21    31    41\n2:     2    12    22    32    42\n3:     3    13    23    33    43\n4:     4    14    24    34    44\n5:     5    15    25    35    45\n```\n:::\n:::\n\n\nTo operate row-wise, we can use `by = 1:nrow(dt)`.\nFor example, to add a column, in-place, with row-wise sums of variables b \nthrough d:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, bcd.sum := sum(.SD[, b:d]), by = 1:nrow(dt)]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       a     b     c     d     e bcd.sum\n   <int> <int> <int> <int> <int>   <int>\n1:     1    11    21    31    41      63\n2:     2    12    22    32    42      66\n3:     3    13    23    33    43      69\n4:     4    14    24    34    44      72\n5:     5    15    25    35    45      75\n```\n:::\n:::\n\n\n## Save a `data.table` to file\n\nSame as any R object, you can save a `data.table` to disk using `saveRDS()`.\nSuppose you have read data in with `fread()` or coerced a dataset using \n`as.data.table()`, done some cleaning up, type conversions, data \ntransformations, etc, this is the preferred way to save your work, so you can \nreload at any time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(dt, \"/path/to/data.rds\")\n```\n:::\n\n\n## Resources\n\n- [Introduction to data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)\n- [Using .SD for Data Analysis](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-sd-usage.html)\n",
    "supporting": [
      "dtBasics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}