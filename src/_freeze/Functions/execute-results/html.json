{
  "hash": "c6941e51baf32982a294dcef5bed8eab",
  "result": {
    "markdown": "---\nexecute: \n  warning: false\nknitr:\n  opts_knit:\n    global.par: true\n  opts_chunk: \n    comment: ''\n---\n\n# Functions {#sec-functions}\nWriting functions is a core part of programming.\n\n*When should you write a function?*\n\nWhenever you find yourself repeating pieces of code.\n\n*Why is it important?*\n\nWriting functions helps reduce the total amount of code, which increases \nefficiency, reduces the chance of error, and can make code more readable.\n<br><br>\nFunctions in R are \"first-class objects\".\n\nThis means they can be stored inside other objects (e.g. a list), they can be \npassed as arguments to other functions (as we see in @sec-loopfns) and can \nbe returned as output from functions.\n<br><br>\nFunctions in R are *for the most part* like mathematical functions: they have \none or more inputs and one output. The inputs are known as the function \narguments. If you want to return multiple outputs, you can return a list \ncontaining any number of R objects.\n<br><br>\nFunctions are refered to as \"closures\" in R. A closure is made of \na function and its environment. Closures are distinct from primitive functions\n(i.e. internally implemented / built-in functions, which are written in C).\n\n## Simple functions\n\nLet's start with a very simple function: single argument with no default value:\n\nDefine the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) {\n  x^2\n}\n```\n:::\n\n\nTry our new function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n\nNotice above that `x^2` is automatically returned by the function. It is the \nsame as explicitly returning it with `return()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) {\n  return(x^2)\n}\n\nsquare(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n\nalso same:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) {\n  out <- x^2\n  return(out)\n}\n\nsquare(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n\nstill same:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) {\n  out <- x^2\n  out\n}\n\nsquare(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\nA function returns either:\n\n- the value of the last expression within the function definition such as `out` \nor `x^2` above.\n- an object passed to `return()`\n\nMultiple arguments, with and without defaults:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraise <- function(x, power = 2) {\n  x^power\n}\n\nx <- sample(10, 1)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nraise(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\nraise(x, power = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000\n```\n\n\n:::\n\n```{.r .cell-code}\nraise(x, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n`return()` can be used to exit a function early\n:::\n\nIn the following example, `return()` is used to exit the function early if no negative \nvalues are found. This is shown only as a trivial example; it is not particularly\nuseful in this case, but can be useful in more complex functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreproc <- function(x) {\n  if (all(x >= 0)) {\n    return(x) \n  } else {\n    cat(\"Negative values found, returning absolute \\n\")\n    return(abs(x))\n  }\n}\n```\n:::\n\n\nThe following stops early and no message is printed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreproc(0:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\nThe following does not stop early and message is printed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreproc(-5:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNegative values found, returning absolute \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 5 4 3 2 1 0 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n## Argument matching\n\nR will match unambiguous abbreviations of arguments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn <- function(alpha = 2, beta = 3, gamma = 4) {\n  alpha * beta + gamma\n}\nfn(g = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\n## Arguments with prescribed set of allowed values\n\nYou can match specific values for an argument using `match.arg()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfn <- function(type = c(\"alpha\", \"beta\", \"gamma\")) {\n  type <- match.arg(type)\n  cat(\"You have selected type '\", type, \"'\\n\", sep = \"\")\n}\n\nmyfn(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYou have selected type 'alpha'\n```\n\n\n:::\n\n```{.r .cell-code}\nmyfn(\"b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYou have selected type 'beta'\n```\n\n\n:::\n\n```{.r .cell-code}\nmyfn(\"g\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYou have selected type 'gamma'\n```\n\n\n:::\n\n```{.r .cell-code}\nmyfn(\"d\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in match.arg(type): 'arg' should be one of \"alpha\", \"beta\", \"gamma\"\n```\n\n\n:::\n:::\n\n\nAbove you see that partial matching using `match.arg()` was able to identify a \nvalid option, and when there was no match, an informative error was printed.\n\nPartial matching is also automatically done on the argument names themselves, \nbut it's important to avoid depending on that. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsr <- function(attack = 100,\n                 decay = 250,\n                 sustain = 40,\n                 release = 1000) {\n  cat(\"Attack time:\", attack, \"ms\\n\",\n      \"Decay time:\", decay, \"ms\\n\",\n      \"Sustain level:\", sustain, \"\\n\",\n      \"Release time:\", release, \"ms\\n\")\n}\n\nadsr(50, s = 100, r = 500)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAttack time: 50 ms\n Decay time: 250 ms\n Sustain level: 100 \n Release time: 500 ms\n```\n\n\n:::\n:::\n\n\n## Passing extra arguments to another function with the `...` argument\n\nMany functions include a `...` argument at the end. Any arguments not otherwise \nmatched are collected there. A common use for this is to pass them to another \nfunction:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncplot <- function(x, y,\n                  cex = 1.5,\n                  pch = 16,\n                  col = \"#18A3AC\",\n                  bty = \"n\", ...) {\n\n  plot(x, y, \n       cex = cex, \n       pch = pch, \n       col = col, \n       bty = bty, ...)\n\n}\n```\n:::\n\n\n`...` is also used for variable number of inputs, often as the first argument of \na function. For example, look at the documentation of `c()`, `cat()`, `cbind()`, \n`paste()`  \n\n:::{.callout-note}\nAny arguments after the `...`, **must** be named fully, i.e. will not be \npartially matched.\n:::\n\n## Return multiple objects\n\nR function can only return a single object. This is not much of a problem \nbecause you can simply put any collection of objects into a list and return it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfn <- function(x, fn = square) {\n  xfn <- fn(x)\n  \n  list(x = x,\n       xfn = xfn,\n       fn = fn)\n}\n\nlfn(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n[1] 3\n\n$xfn\n[1] 9\n\n$fn\nfunction(x) {\n  out <- x^2\n  out\n}\n<bytecode: 0x108ede5f8>\n```\n\n\n:::\n:::\n\n\n## Warnings and errors\n\nYou can use `warning(\"some warning message\")` at any point inside a function to \nproduce a warning message during execution. The message gets printed to the R \nconsole, but function execution is **not** stopped.  \n\nOn the other hand, you can use `stop(\"some error message\")` to print an error \nmessage to console and stop function execution.\n\nThe following function (`el10`) calculates:\n$$ e^{log_{10}(x)} $$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nel10 <- function(x) {\n  exp(log10(x))\n}\n```\n:::\n\n\nwhich is not defined for negative `x`. In this case, we could let R give a \nwarning when it tries to compute `log10(x)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nval1 <- el10(-3)\n```\n:::\n\n\nWe could instead produce our own warning message:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nel10 <- function(x) {\n  if (x < 0) warning(\"x must be positive\")\n  exp(log10(x))\n}\nval2 <- el10(-3)\nval2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\nAs you see, the output (`NaN`) still gets returned.\n\nAlternatively, we can use `stop()` to end function execution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nel10 <- function(x) {\n  if (x < 0) stop(\"x must be positive\")\n  exp(log10(x))\n}\nval3 <- el10(-3)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in el10(-3): x must be positive\n```\n\n\n:::\n:::\n\n\nNote how, in this case, function evaluation is stopped and no value is \nreturned.\n\n## Scoping\n\nFunctions exist in their own environment, i.e. contain their own variable \ndefinitions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\ny <- 4\nfn <- function(x, y) {\n  x <- 10*x\n  y <- 20*y\n  cat(\"Inside the function, x = \", x, \" and y = \", y, \"\\n\")\n}\n\nfn(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInside the function, x =  30  and y =  80 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Outside the function, x = \", x, \" and y = \", y, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOutside the function, x =  3  and y =  4 \n```\n\n\n:::\n:::\n\n\nHowever, if a variable is referenced within a function but no local definition \nexists, the interpreter will look for the variable at the parent environment. It \nis best to ensure all objects needed within a function are specified as \narguments and passed appropriately when the function is called.  \n\nIn the following example, `x` is only defined outside the function definition, \nbut referenced within it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 21\n\nitfn <- function(y, lr = 1) {\n  x + lr * y\n}\n\nitfn(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24\n```\n\n\n:::\n:::\n\n\n### function vs. for loop\n\nLet's z-score the built-in `mtcars` dataset once with a for loop and once with \na custom function. This links back to the example seen earlier in the \n[for loop](#fordata) section. In practice, this would be performed with the \n`scale()` command:\n\nWithin the for loop, we are assigning columns directly to the object \ninitialized before the loop. In the following example, we use \n`print(environment())` to print the environment outside and inside the loop \nfunction to show that it is the same. This is purely for demonstration:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# initialize new object 'mtcars_z'\nmtcars_z <- mtcars\ncat(\"environment outside for loop is: \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nenvironment outside for loop is: \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(environment())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\n# z-score one column at a time in a for loop\nfor (i in seq_len(ncol(mtcars))) {\n  mtcars_z[, i] <- (mtcars[, i] - mean(mtcars[, i])) / sd(mtcars[, i])\n  cat(\"environment inside for loop is: \")\n  print(environment())\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\nenvironment inside for loop is: <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\nIn contrast, all operations remain local within a function and the output must \nbe returned:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nztransform <- function(x) {\n  cat(\"environment inside function body is: \")\n  print(environment())\n  z <- as.data.frame(sapply(mtcars, function(i) (i - mean(i))/sd(i)))\n  rownames(z) <- rownames(x)\n  z\n}\nmtcars_z2 <- ztransform(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nenvironment inside function body is: <environment: 0x13a717f68>\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"environment outside function body is: \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nenvironment outside function body is: \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(environment())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\nNotice how the environment outside and inside the loop function is the same, it \nis the Global environment, but the environment within the function is different. \nThat is why any objects created or changed within a function must be returned \nif we want to make them available.\n\n## The pipe operator {#pipe}\n\n:::{.callout-note}\nIn its basic form, a pipe allows writing:\n`f(x)`\nas\n`x |> f()`\nand, similarly,\n`g(f(x))`\nas\n`x |> f() |> g()`\n:::\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Illustration of pipes in R](./R_pipes.png){#fig-pipe fig-align='center' width=80%}\n:::\n:::\n\n\nA pipe operator was first introduced to R by the \n[magrittr](https://magrittr.tidyverse.org/) package with the `%>%` symbol. Note \nthat a number of other packages that endorse the use of pipes export the pipe \noperator as well.  \n\nStarting with R version 4.1, a native pipe operator is included with the `|>` \nsymbol.\n\nA pipe allows writing `f(x)` as `x |> f()` (native pipe) or `x %>% f` \n(magrittr).\n\nNote that the native pipe requires parentheses, but magrittr works with or \nwithout them.\n\nA pipe is often used to:\n\n- avoid multiple temporary assignments in a multistep procedure, or \n- as an alternative to nesting functions. \n\nSome packages and developers promote its use, others discourage it. You should \ntry and see if/when it suits your needs.\n\nThe following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- f1(x)\nx <- f2(x)\nx <- f3(x)\n```\n:::\n\n\nis equivalent to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- f3(f2(f1(x)))\n```\n:::\n\n\nis equivalent to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- x |> f1() |> f2() |> f3()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niris[, -5] |>\n  split(iris$Species) |>\n  lapply(function(i) sapply(i, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$setosa\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n       5.006        3.428        1.462        0.246 \n\n$versicolor\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n       5.936        2.770        4.260        1.326 \n\n$virginica\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n       6.588        2.974        5.552        2.026 \n```\n\n\n:::\n:::\n\n\nPipes are used extensively in the [tidyverse](https://www.tidyverse.org) \npackages and many \nother third-party packages.  \nYou can learn more about the magrittr pipe operator in the \n[vignette](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html)\n\n::: callout-tip\nIn [RStudio](https://posit.co/products/open-source/rstudio/) the keyboard shortcut for the pipe operator \nis `Shift-Command-M` (MacOS) or `Ctrl-Shift-M` (Windows)\n:::\n\n### Differences between native pipe and **magrittr**\n\n- native pipe requires `()` after function name, **magrittr** works with or \nwithout them\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(300)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.03173992\n```\n\n\n:::\n:::\n\n\nbut this would fail:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> mean\n```\n:::\n\n\nwhile either works in **magrittr**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\nx %>% mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.03173992\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx %>% mean\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.03173992\n```\n\n\n:::\n:::\n\n\n- native pipe by design only pipes its LHS to the first ***unnamed*** argument \non the RHS. **magrittr** allows using a period `.` to pipe to any position on \nthe RHS. The native pipe workaround is using an anonymous function (can use the \nnew shorter syntax `\\(x)` instead of `function(x)`)\n\ne.g.: Find the position of \"r\" in the latin alphabet\n\nIn this example, we want to pass the LHS to the second argument of `grep()`.\n\nUsing native pipe, we name the first argument `pattern` and the LHS is passed \nto the first unnamed argument, i.e. the second (which is `x`, the character \nvector where matches are looked for)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters |> grep(pattern = \"r\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\nwith **magrittr** you can use the dot notation to specify where to pipe into:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters %>% grep(\"r\", .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\nFor demonstration, here's the slightly involved way you would achieve this with \nan anonymous function and the native pipe. This may make sense for more complex \ncalls.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters |> {\\(x) grep(\"r\", x)}()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\n## Further reading\n\nSee [`roxygen2`](https://roxygen2.r-lib.org/) for writing inline comments that\ncan generate complete documentation for your functions.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}