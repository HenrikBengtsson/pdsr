{
  "hash": "d05b2c50df40630e5cd8d8329ff8d7e9",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk:\n    comment: \"\"\n    cache: true\n---\n\n# Factors {#sec-factors}\n\nFactors in R are used to store **categorical variables** and therefore have \nmany important uses in statistics / data science / machine learning.  \n\nFor example, factors can be used to store information on sex, race, diagnosis, \ntreatment group, etc.\n<br><br>\n\n\n::: {.cell layout-align=\"center\" hash='Factors_cache/html/fig-factors_005021c47f09b1f17e0216105e023015'}\n::: {.cell-output-display}\n![Factors in R - Best to read through this chapter first and then refer back to this figure](./R_factors.png){#fig-factors fig-align='center' width=80%}\n:::\n:::\n\n\nIf you are new to R and to factors, begin with the following introductory-level \nsection.\n\n## Factors (introductory) {#factorsintro}\n\n::: callout-note\nFactors in R are a special type of vector.\n\n- Each element can take one value from a set known as the factor's \n**levels**.\n\n- A factor's levels are stored in a particular **order**, which affects how that \nfactor is treated by some functions, e.g. in hypothesis testing, model fitting,\nvisualization, etc.\n\n- You can specify whether or not the order of the levels defines a quantitative \nrelationship such that level1 < level2, etc., in which case the factor is known \nas **ordered**.\n:::\n\nYou can create a factor by passing a numeric or character vector to `factor()` \nor to `as.factor()`.\n\nThe difference between the two is that `as.factor()` does not accept any \narguments while `factor()` does.\n\nLet's start with a character vector that includes three unique values - \n\"a\", \"b\", and \"c\":\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-2_3d3143428a0d848c85d9523fd50baa79'}\n\n```{.r .cell-code}\nx <- c(\"a\", \"c\", \"b\", \"b\", \"a\", \"a\", \"b\", \"c\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"c\" \"b\" \"b\" \"a\" \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\nAssume that \"a\", \"b\", and \"c\" define three different groups and we want to \nconvert this character vector to a factor.  \n`as.factor()` and `factor()` without any arguments produce the same output:\n\n### Create a factor\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-3_67a4647078441c912b37e4e51737b373'}\n\n```{.r .cell-code}\nxf <- factor(x)\nxf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a c b b a a b c\nLevels: a b c\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(xf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nxftoo <- as.factor(x)\nxftoo\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a c b b a a b c\nLevels: a b c\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(xftoo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\nNotice how a factor is printed in the R console: \n\n- The elements are printed without double quotes around them, differentiating \nthem from character vectors.\n- The factor levels are printed below the vector values.\n\n`table()` is a very useful function for factors - it gives the counts for each \nlevel:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-4_2e076672219815bc13fc36537785a0ca'}\n\n```{.r .cell-code}\ntable(xf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nxf\na b c \n3 3 2 \n```\n\n\n:::\n:::\n\n\nLet's look at a different example. We define a factor to identify cases and \ncontrols:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-5_8e4ecd1607eb9970b04943756f9aa4e4'}\n\n```{.r .cell-code}\ng <- factor(c(\"case\", \"control\", \"control\", \"case\", \"control\"))\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] case    control control case    control\nLevels: case control\n```\n\n\n:::\n:::\n\n\n::: callout-note\nBy default, the levels are ordered *alphabetically*.\n:::\n\n### Set the order of factor levels\n\nYou can define the order of the factor levels with the `levels` argument of the \n`factor()` function.\n\nFor example, the first factor level is used as the baseline in some statistical \noperations, e.g. `glm()`, in which case the \"control\" level should be first.\n\nMany plotting functions order categorical axes' labels using the level order.\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-6_ad119db40bf265215306edc6b15112f7'}\n\n```{.r .cell-code}\ng <- factor(c(\"case\", \"control\", \"control\", \"case\", \"control\"),\n            levels = c(\"control\", \"case\"))\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] case    control control case    control\nLevels: control case\n```\n\n\n:::\n:::\n\n\nThe `levels` argument can include values not present in the input data vector. \nThis may be used for example when some known categories are not present in your \nsample, but may be added in the future, or you want specifically to show they \nare absent in a table or a plot, etc.\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-7_23caacbe1e8c105d26af1319d32f1d02'}\n\n```{.r .cell-code}\ng <- factor(c(\"Type I\", \"Type III\", \"Type III\", \"Type I\"),\n            levels = c(\"Type I\", \"Type II\", \"Type III\"))\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Type I   Type III Type III Type I  \nLevels: Type I Type II Type III\n```\n\n\n:::\n:::\n\n\nOn the other hand, if the `levels` argument is specified and does not include \none or more of the values present in the input data vector, the corresponding \nelements become `NA`:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-8_a6803bd1a77ba44209b61350d32fc466'}\n\n```{.r .cell-code}\ng <- factor(c(\"case\", \"control\", \"undefined\", \"control\", \n              \"case\", \"control\", \"undefined\"),\n            levels = c(\"control\", \"case\"))\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] case    control <NA>    control case    control <NA>   \nLevels: control case\n```\n\n\n:::\n:::\n\n\n### Define level labels\n\nYou can define level names or ***labels*** other than the values in the \ninput vector using the `labels` argument:\n\nAssume you started with the following character vector:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-9_01bcea09104def2943bc99c36213c338'}\n\n```{.r .cell-code}\nx <- c(\"female\", \"female\", \"male\", \"female\", \"male\")\n```\n:::\n\n\nYou can attach different labels to each level rather than default to \n\"female\" and \"male\" by passing a character vector to the `labels` arguments:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-10_15babbf61cdd5a30942daf06cf50ba2a'}\n\n```{.r .cell-code}\nxf <- factor(x, labels = c(\"F\", \"M\"))\nxf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] F F M F M\nLevels: F M\n```\n\n\n:::\n:::\n\n\nThe order of names in the `labels` argument must match the order of levels. \nIn the above example, the levels default to `c(\"female\", \"male\")` because they \nare sorted alphabetically if not specified. Otherwise, we can specify both the \n`levels` and `labels` arguments to define both order of levels and provide \nnew labels:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-11_fc04e9612619e41e01640d2301ee87da'}\n\n```{.r .cell-code}\nxf <- factor(x, \n             levels = c(\"male\", \"female\"),\n             labels = c(\"M\", \"F\"))\nxf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] F F M F M\nLevels: M F\n```\n\n\n:::\n:::\n\n\n### Change level labels of existing factor\n\nWe can change the labels of a factor object \n\n- using the `labels` argument of the `factor()` command in the same way we \ncreate a factor from a character or other vector\n- using the `levels()` command\n\nStart with a factor of two groups and change labels using the `factor()` \ncommand:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-12_a187e716925cfac6a86a0408c4acc991'}\n\n```{.r .cell-code}\nxf <- factor(c(\"GroupA\", \"GroupB\", \"GroupB\", \"GroupA\"))\nxf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] GroupA GroupB GroupB GroupA\nLevels: GroupA GroupB\n```\n\n\n:::\n:::\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-13_c9810f4d47c6192f75d87ed986fd7841'}\n\n```{.r .cell-code}\nxf <- factor(xf, labels = c(\"A\", \"B\"))\nxf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] A B B A\nLevels: A B\n```\n\n\n:::\n:::\n\n\nStart with the same factor and change labels using the `levels()` command.\n\nThis is similar to using `colnames()` on a data.frame and is much faster than \nusing `factor()` as above:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-14_797f0c2fa192b7a2823f8d71de9f6728'}\n\n```{.r .cell-code}\nxf <- factor(c(\"GroupA\", \"GroupB\", \"GroupB\", \"GroupA\"))\nlevels(xf) <- c(\"A\", \"B\")\nxf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] A B B A\nLevels: A B\n```\n\n\n:::\n:::\n\n\n::: callout-caution\nThe `levels()` command changes the ***names*** of the levels. \nIt ***cannot be used to change the order of levels***, \nwhich must be done using `factor()`.\n:::\n\n## Factors (advanced)\n\n::: callout-note\nA factor is a vector\nA factor contains three crucial pieces of information:\n\n1. The underlying **integer vector**\n\n2. The **mapping of integers to labels**\n\n3. Whether the factor is **ordered**\n:::\n\nLet's unpack these.  \n\nBegin with a simple factor:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-15_6e97ad5a92ebc5df54cd95d65c96a154'}\n\n```{.r .cell-code}\nx <- factor(c(\"female\", \"female\", \"female\", \"male\", \"male\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] female female female male   male  \nLevels: female male\n```\n\n\n:::\n:::\n\n\nInternally, the command sees there are two distinct labels, female and male, \nand defaults to assigning integer numbers alphabetically, in this case female \nhas been mapped to '1' and male to '2'.\n\nPrinting a factor prints the vector of labels followed by the levels, i.e. the \nunique labels.  \n\n### The underlying **integer vector**\n\nEach level is assigned an integer. (Internally, this is the \"data\" that forms \nthe elements of a factor vector). You don't see these integers unless you \nconvert the factor to numeric (`as.numeric()`) or look at the (truncated) \noutput of `str()`;\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-16_15aebaf60b78abbf157b584448be4a99'}\n\n```{.r .cell-code}\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 1 2 2\n```\n\n\n:::\n:::\n\n\n### The **mapping of integers to labels**\n\nThis defines which integer is mapped to which label, i.e. whether 1 is mapped \nto male or female. You can store the same information regardless which one you \nchoose to call 1 and 2. \n\nTo get the mapping you can use `levels()`. It prints the labels in order:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-17_76062c04f844f40dc5eb15d49f7858c8'}\n\n```{.r .cell-code}\nlevels(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"female\" \"male\"  \n```\n\n\n:::\n:::\n\n\nAgain, this means that female is mapped to 1 and male is mapped to 2.\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-18_dcb9a1c5b2de1316b3de0f60aed51c6c'}\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 2 levels \"female\",\"male\": 1 1 1 2 2\n```\n\n\n:::\n:::\n\n\nThe above tells you that x is a factor,  \nit has two levels labeled as \"female\" and \"male\", in that order, i.e. female is \nlevel 1 and male is level 2.    \nThe last part shows that the first five elements (in this case the whole \nvector) consists of three elements of level 1 (female) followed by 2 elements \nof level 2 (male).\n\n#### Setting new level labels\n\nYou can use the `levels()` command with an assignment to assign new labels to a \nfactor (same syntax to how you use `rownames()` or `colnames()` to assign new \nrow or column names to a matrix or data frame);\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-19_2fabfd01130f06c00fab2c597db06ae5'}\n\n```{.r .cell-code}\nxf <- factor(sample(c(\"patient_status_positive\", \"patient_status_negative\"), 10, T),\n             levels = c(\"patient_status_positive\", \"patient_status_negative\"))\nxf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] patient_status_positive patient_status_positive patient_status_positive\n [4] patient_status_negative patient_status_negative patient_status_negative\n [7] patient_status_positive patient_status_positive patient_status_negative\n[10] patient_status_negative\nLevels: patient_status_positive patient_status_negative\n```\n\n\n:::\n:::\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-20_5ccc00561308457f5f690919316d278e'}\n\n```{.r .cell-code}\nlevels(xf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"patient_status_positive\" \"patient_status_negative\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(xf) <- c(\"positive\", \"negative\")\nxf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] positive positive positive negative negative negative positive positive\n [9] negative negative\nLevels: positive negative\n```\n\n\n:::\n:::\n\n\n#### Defining the mapping of labels to integers\n\nIf you want to define the mapping of labels to their integer representation \n(and not default to them sorted alphabetically), you use the `levels` arguments \nof the `factor()` function.  \n\nThe vector passed to the `levels` arguments must include at least all unique \nvalues passed to `factor()`, otherwise you will get `NA` values.\n\nWithout defining `levels` they are assigned alphabetically:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-21_94bbed368d6a6826ab88e79c41272868'}\n\n```{.r .cell-code}\nx <- factor(c(\"alpha\", \"alpha\", \"gamma\", \"delta\", \"delta\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] alpha alpha gamma delta delta\nLevels: alpha delta gamma\n```\n\n\n:::\n:::\n\nDefine `levels`:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-22_e57c5b85a136e9f18f4acb4736e2e573'}\n\n```{.r .cell-code}\nx <- factor(c(\"alpha\", \"alpha\", \"gamma\", \"delta\", \"delta\"),\n            levels = c(\"alpha\", \"gamma\", \"delta\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] alpha alpha gamma delta delta\nLevels: alpha gamma delta\n```\n\n\n:::\n:::\n\n\nThe `table` command has a number of useful applications, in it simplest form, \nit tabulates number of elements with each unique value found in a vector:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-23_fa41de11d4ae9f78aaf30e35f28be3c9'}\n\n```{.r .cell-code}\ntable(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx\nalpha gamma delta \n    2     1     2 \n```\n\n\n:::\n:::\n\n\nIf you forget (or choose to exclude) a level, all occurrences are replaced by \n`NA`:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-24_c248a5cbb003217601b03b4337c1ecc7'}\n\n```{.r .cell-code}\nx <- factor(c(\"alpha\", \"alpha\", \"gamma\", \"delta\", \"delta\"),\n            levels = c(\"alpha\", \"gamma\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] alpha alpha gamma <NA>  <NA> \nLevels: alpha gamma\n```\n\n\n:::\n:::\n\n\nIf you know that more levels exist, even if no examples are present in your \nsample, you can includes these extra levels:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-25_40d050d412d5c5166ebb5718c3282e7b'}\n\n```{.r .cell-code}\nx <- factor(c(\"alpha\", \"alpha\", \"gamma\", \"delta\", \"delta\"),\n            levels = c(\"alpha\", \"beta\", \"gamma\", \"delta\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] alpha alpha gamma delta delta\nLevels: alpha beta gamma delta\n```\n\n\n:::\n:::\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-26_d2af9a226e11e2cc8e8405c8462c2950'}\n\n```{.r .cell-code}\ntable(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx\nalpha  beta gamma delta \n    2     0     1     2 \n```\n\n\n:::\n:::\n\n\n### Is the factor **ordered**\n\nWe looked at how you can define the order of levels using the `levels` argument \nin `factor()`, which affects the integer mapping to each label.\n\nThis can affect how some applications treat the different levels.\n\nOn top of the order of the mapping, you can further define if there is a \n*quantitative relationship* among levels of the form \n`level 1 < level 2 < ... < level n`. This, in turn, can affect how the factor \nis treated by some functions, like some functions that fit statistical models.\n\n::: callout-note\nAll factors' levels appear in some order or other.\n\nAn **ordered factor** indicates that its levels have a quantitative \nrelationship of the form `level 1 < level 2 < ... < level n`.\n:::\n\nFirst an unordered factor:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-27_e833db611ebaf5205f549172fe4eeb40'}\n\n```{.r .cell-code}\ndat <- sample(c(\"small\", \"medium\", \"large\"), 10, TRUE)\nx <- factor(dat)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] large  medium large  large  large  small  medium small  large  medium\nLevels: large medium small\n```\n\n\n:::\n:::\n\n\nTo make the above into an ordered factor, we need to define the order of the \nlevels with the `levels` arguments and also specify that it is ordered with the \n`ordered` argument:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-28_5722c2cee22fba505b7a7d511e6aa72a'}\n\n```{.r .cell-code}\nx <- factor(dat,\n            levels = c(\"small\", \"medium\", \"large\"),\n            ordered = TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] large  medium large  large  large  small  medium small  large  medium\nLevels: small < medium < large\n```\n\n\n:::\n:::\n\n\nNote how the levels now include the less-than sign (`<`) between levels to indicate the ordering.\n\n### Change order of levels or labels\n\nWe've seen how to create a factor with defined order of levels and how to \nchange level labels already. Because these are prone to serious accidents, \nlet's look at them again, together.\n\n**To change the order of levels** of an existing factor use `factor()`:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-29_b914d429fa2184c9cebf6b8d9cfdbb49'}\n\n```{.r .cell-code}\nx <- factor(c(\"target\", \"target\", \"control\", \"control\", \"control\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] target  target  control control control\nLevels: control target\n```\n\n\n:::\n:::\n\n\nChange the order so that target is first (i.e. corresponds to 1:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-30_685c80c685e4e44f7f96c2c705cbfcec'}\n\n```{.r .cell-code}\nx <- factor(x, levels = c(\"target\", \"control\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] target  target  control control control\nLevels: target control\n```\n\n\n:::\n:::\n\n\n**To change the labels of the levels** use `levels()`:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-31_be48500c6e3154fff296b7f7810916de'}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] target  target  control control control\nLevels: target control\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(x) <- c(\"hit\", \"decoy\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] hit   hit   decoy decoy decoy\nLevels: hit decoy\n```\n\n\n:::\n:::\n\n\n::: callout-caution\nChanging the levels of a factor with `levels()` does not change the internal \ninteger representation but changes every element's label. \n:::\n\n### Fatal error to avoid\n\nExample scenario: You receive a dataset for classification where the outcome is \na factor of 1s and 0s:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-32_3af7a6817ddaa80ce9641b2eb707d383'}\n\n```{.r .cell-code}\noutcome <- factor(c(1, 1, 0, 0, 0, 1, 0))\noutcome\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 0 0 0 1 0\nLevels: 0 1\n```\n\n\n:::\n:::\n\nSome classification procedures expect the first level to be the 'positive' \noutcome, so you decide to reorder the levels.\n\nYou mistakenly use `levels()` instead of `factor(x, levels = c(...))` hoping to \nachieve this.  \n\nYou end up flipping all the outcome values.\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-33_5d4a867e352a1e411d2533dba74fb905'}\n\n```{.r .cell-code}\nlevels(outcome) <- c(\"1\", \"0\")\noutcome\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 1 1 1 0 1\nLevels: 1 0\n```\n\n\n:::\n:::\n\n\nAll zeros became ones and ones became zeros.\n\nYour model does the exact opposite of what you intended.\n\n### Factor to numeric\n\nWhile it often makes sense to have factors with words for labels, they can be \nany character and that includes numbers (i.e. numbers which are treated as \nlabels)\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-34_051ccd381ae6acf55172c05a416b9524'}\n\n```{.r .cell-code}\nf <- factor(c(3, 7, 7, 9, 3, 3, 9))\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 7 7 9 3 3 9\nLevels: 3 7 9\n```\n\n\n:::\n:::\n\n\nThis behaves just like any other factor with all the rules we learned above.\n\nThere is a very easy trap to fall into, if you ever decide to convert such a \nfactor to numeric.\n\nThe first thing that usually comes to mind is to use `as.numeric()`.\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-35_e3c9a7c824d99b25a5de042b88b21072'}\n\n```{.r .cell-code}\n# !don't do this!\nas.numeric(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 2 3 1 1 3\n```\n\n\n:::\n:::\n\nBut! We already know this will return the integer index, it will not return the \nlabels as numbers.  \n\nBy understanding the internal representation of the factor, i.e. that a factor \nis an integer vector indexing a set of labels, you can convert labels to \nnumeric exactly by indexing the set of labels:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-36_43e7948fe8a788002be484aa507b475c'}\n\n```{.r .cell-code}\nlevels(f)[f]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\" \"7\" \"7\" \"9\" \"3\" \"3\" \"9\"\n```\n\n\n:::\n:::\n\nThe above suggests that used as an index within the brackets, `f` is coerced to \ninteger, therefore to understand the above:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-37_4bbca7ba13b6d142ca96fb15341f2eca'}\n\n```{.r .cell-code}\nlevels(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\" \"7\" \"9\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(f)[as.integer(f)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\" \"7\" \"7\" \"9\" \"3\" \"3\" \"9\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# same as\nlevels(f)[f]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\" \"7\" \"7\" \"9\" \"3\" \"3\" \"9\"\n```\n\n\n:::\n:::\n\n\nA different way around this that may be less confusing is to simply convert the \nfactor to character and then to numeric:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-38_7e901f814b2403affdff871446e967ef'}\n\n```{.r .cell-code}\nas.numeric(as.character(f))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 7 7 9 3 3 9\n```\n\n\n:::\n:::\n\n\n## Interactions\n\nOn many different occasions we want to look at factor interactions, e.g. for\nvisualization, statistical hypothesis testing, predictive modeling, etc.\nSome functions allow you to define factors that should be allowed to interact\nand take of the rest for you. To explicitly create a factor interaction, you\ncan use the `interaction()` function:\n\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-39_2160c02b153a827c3d9506ddcddc5f78'}\n\n```{.r .cell-code}\nset.seed(2022)\ndat <- data.frame(PID = 8001:8009,\n                  Sex = factor(sample(c(\"male\", \"female\"), 9, TRUE)),\n                  Group = factor(sample(c(\"A\", \"B\"), 9, TRUE)))\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   PID    Sex Group\n1 8001 female     B\n2 8002   male     A\n3 8003 female     A\n4 8004   male     B\n5 8005   male     B\n6 8006 female     A\n7 8007 female     A\n8 8008   male     B\n9 8009 female     A\n```\n\n\n:::\n:::\n\n::: {.cell hash='Factors_cache/html/unnamed-chunk-40_fc893d950877b11f8aa10b22a4758898'}\n\n```{.r .cell-code}\ndat[\"Sex_x_Group\"] <- interaction(dat[[\"Sex\"]], dat[[\"Group\"]])\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   PID    Sex Group Sex_x_Group\n1 8001 female     B    female.B\n2 8002   male     A      male.A\n3 8003 female     A    female.A\n4 8004   male     B      male.B\n5 8005   male     B      male.B\n6 8006 female     A    female.A\n7 8007 female     A    female.A\n8 8008   male     B      male.B\n9 8009 female     A    female.A\n```\n\n\n:::\n:::\n\n\n## Summary\n\n::: callout-note\n- Factors in R are essentially ***integer vectors with labels***.\n\n- A factor's internal integer values range from 1 to the number of levels, i.e. \ncategories.\n\n- Each integer corresponds to a label.\n\n- **To set order of levels**: `factor(x, levels = levels_in_desired_order)` to \norder levels\n\n- **To change labels**: `levels(x) <- newlabels` or \n`factor(x, labels = newlabels)`   \n:::\n\n::: callout-note\nTo avoid confusion, do not use numbers as level labels, if possible.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}