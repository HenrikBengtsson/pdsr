{
  "hash": "0dbae71d17156e92a00ad5ce715c7119",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk:\n    comment: \"\"\n---\n\n# Classes and OOP {#sec-classes}\n\nObject-Oriented Programming (OOP) is a programming paradigm built around \nobjects with associated data, known as attributes, and functions, known as \nmethods.  \n\nThere are 4 main class systems in R:  \n\n- **S3**: informally defined, minimal, lean: methods dispatch based on class; \n`base` and `stats` packages use S3 exclusively\n- **S4**: formally defined, allows method dispatch on multiple arguments\n- **RC**: Reference class: Reference semantics; similar to other programming \nlanguages; methods are part of the object\n- **R6**: 3rd party class system similar to RC, more lightweight, faster\n\nS3 and S4 methods are part of generic functions. RC and R6 methods are part of \nthe object, but you can (and should) write generic functions for them as well.  \n\nThis chapter will focus on the ubiquitous S3 system. For more advanced, and \nreal OOP applications, we recommend looking into the \n[R6](https://r6.r-lib.org/index.html) system.\n\n## S3\n\nMost R objects we have been using so far are S3 objects. Data frames are some \nof the most common S3 objects.  \n\nGeneric functions are functions that act differently based on the class of the \ninput object. We have already used many of them. For example, `summary()` \nworks differently on a `data.frame`, on a `factor`, or a `glm` object, etc.\n\nGeneric functions in R are saved as `functionname.classname()` and called \nautomatically, based on the class of the first argument. This allows the same \nfunction, e.g. `print()`, `summary()`, `c()`, to have a different effect on \nobjects of different classes.\nFor example, the `print()` function applied on a data frame, will actually \ncall `print.data.frame()`, while applied on a factor, it will call \n`print.factor()`.  \nThis means that when you type `print(iris)` this calls `print.data.frame(iris)`.\n<br><br>\nNote how the R documentation lists usage information separately for each S3 \nmethod, e.g. `## S3 method for class 'factor'`.\n\n### `methods()` {#s3methods}\n\nTo get a list of all available methods defined for a specific class,  \ni.e. ***\"What functions can I use on this object?\"***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = \"data.frame\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] [             [[            [[<-          [<-           $<-          \n [6] aggregate     anyDuplicated anyNA         as.data.frame as.list      \n[11] as.matrix     as.vector     by            cbind         coerce       \n[16] dim           dimnames      dimnames<-    droplevels    duplicated   \n[21] edit          format        formula       head          initialize   \n[26] is.na         Math          merge         na.exclude    na.omit      \n[31] Ops           plot          print         prompt        rbind        \n[36] row.names     row.names<-   rowsum        show          slotsFromS3  \n[41] split         split<-       stack         str           subset       \n[46] summary       Summary       t             tail          transform    \n[51] type.convert  unique        unstack       within        xtfrm        \nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\nConversely, to get a list of all available methods for a generic function,\ni.e. ***\"What objects can I use this function on?\"***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(generic.function = \"plot\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] plot.acf*           plot.data.frame*    plot.decomposed.ts*\n [4] plot.default        plot.dendrogram*    plot.density*      \n [7] plot.ecdf           plot.factor*        plot.formula*      \n[10] plot.function       plot.hclust*        plot.histogram*    \n[13] plot.HoltWinters*   plot.isoreg*        plot.lm*           \n[16] plot.medpolish*     plot.mlm*           plot.ppr*          \n[19] plot.prcomp*        plot.princomp*      plot.profile.nls*  \n[22] plot.raster*        plot.spec*          plot.stepfun       \n[25] plot.stl*           plot.table*         plot.ts            \n[28] plot.tskernel*      plot.TukeyHSD*     \nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\n### Defining custom S3 classes\n\nIt very simple to assign an object to a new class.  \nThere is no formal class definition, an object is directly assigned to a class \nby name. An object can belong to multiple classes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nclass(x) <- c(\"specialvector\", \"numeric\")\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"specialvector\" \"numeric\"      \n```\n\n\n:::\n:::\n\n\nThe hierarchy of classes goes left to right, meaning that generic methods are \nsearched for classes in the order they appear in the output of `class()`.\n\nIf we print `x`, since there is no print method for class `specialvector` or \nfor `numeric`, the default `print.default()` command is automatically called:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\nattr(,\"class\")\n[1] \"specialvector\" \"numeric\"      \n```\n\n\n:::\n\n```{.r .cell-code}\nprint.default(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\nattr(,\"class\")\n[1] \"specialvector\" \"numeric\"      \n```\n\n\n:::\n:::\n\n\nTo create a custom `print()` function for out new class `specialvector`, we \ndefine a function named `print.[classname]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.specialvector <- function(x, ...) {\n  cat(\"This is a special vector of length\", length(x), \"\\n\")\n  cat(\"Its mean value is\", mean(x, na.rm = TRUE), \n      \"and its median is\", median(x, na.rm = TRUE))\n  cat(\"\\nHere are the first few elements:\\n\", head(x), \"\\n\")\n}\n```\n:::\n\n\nNow, when you print an object of class `specialvector`, the custom `print()` \ncommand is invoked:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThis is a special vector of length 10 \nIts mean value is 5.5 and its median is 5.5\nHere are the first few elements:\n 1 2 3 4 5 6 \n```\n\n\n:::\n:::\n\n\nIf needed, you can call the default or another appropriate method directly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.default(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\nattr(,\"class\")\n[1] \"specialvector\" \"numeric\"      \n```\n\n\n:::\n:::\n\n\nYou can change the vector back to a regular numeric vector, or a different \nclass, just as easily:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x) <- \"numeric\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}