{
  "hash": "8d61beb19ce2c706efe63f14e1f39336",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk:\n    comment: \"\"\n---\n\n# Strings {#sec-strings}\n\n\"Strings\", in programming, refer to collections of characters, i.e. text data. In R, \ntext is usually stored as objects of class \"character\" (See @sec-datatypes). In \nstatistics/machine learning/data science, we come across text in a few different ways.\nAll the following are character vectors:\n\n- Character variables: each element could include a single word or multiple words, e.g.\npatient name, diagnosis, department name, medication, or entire paragraphs of text, e.g.\nclinical examination notes, test reports, etc.\n- Column names of a data.frame or data.table\n- Factor level names\n\nSome important string operations include:\n\n- Creating character vectors\n- Formatting strings\n- Searching for patterns in strings\n- Replacing patterns in strings\n\n## Creating character vectors\n\n[Reminder](#charactervectors): To initialize, coerce, test character vectors, use:\n\n* `character()`: Initialize empty character vector\n* `as.character()`: Coerce vector to character vector\n* `is.character()`: Test if object is character\n\nInitialize character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- character(10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\n```\n\n\n:::\n:::\n\n\nCoerce to character:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(10, 20, 22, 43)\nx <- as.character(v)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"10\" \"20\" \"22\" \"43\"\n```\n\n\n:::\n:::\n\n\nTest object is character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"PID\", \"Age\", \"Sex\", \"Handedness\")\nis.character(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n### `cat()`: Concatenate and **print**\n\n`cat()` concatenates its inputs to prints to screen (console) or to file.\n\n`cat()` **does not return any object**. It is therefore useful for producing informative \nmessages in your programs.\n\nIt can concatenate strings along with the output of expressions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsbp <- 130\ntemp <- 98.4\ncat(\"The blood pressure was\", sbp, \"and the temperature was\", temp, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe blood pressure was 130 and the temperature was 98.4 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nweight <- 74\nheight <- 1.78\ncat(\"The weight is\", weight, \"and the height is\", height, \n    \"giving a BMI of\", signif(weight/height^2, 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe weight is 74 and the height is 1.78 giving a BMI of 23.4 \n```\n\n\n:::\n:::\n\n\nUse the `file` argument to write to a text file. The `append` argument allows \nusing multiple consecutive `cat()` calls to append to the same file.\n\n:::{.callout-note}\nif you use `cat()` on a factor, it will print the integer index of the\nfactor levels.\n:::\n\nIf you wish to print the levels themselves, use `as.character()`\non the factor vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(head(iris$Species), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 1 1 1 1 1 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(as.character(head(iris$Species)), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsetosa setosa setosa setosa setosa setosa \n```\n\n\n:::\n:::\n\n\n### `paste()`: Concatenate character vectors\n\nIn its simplest form, `paste()` acts like `as.character()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(10, 20, 22, 43)\npaste(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"10\" \"20\" \"22\" \"43\"\n```\n\n\n:::\n:::\n\n\nBut, its main job is to combine strings.\n\nIt can combine two or more strings into one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst = \"Jane\"\nlast = \"Artiste\"\nID = \"8001\"\npaste(ID, last, first)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8001 Artiste Jane\"\n```\n\n\n:::\n:::\n\n\nThe `sep` argument defaults to a single space (\" \") and defines the separator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(ID, last, first, sep = \" | \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8001 | Artiste | Jane\"\n```\n\n\n:::\n:::\n\n\n`paste()` is [vectorized](#sec-vectorization), which means it can combine character \nvectors elementwise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid = c(\"001\", \"010\", \"018\", \"020\", \"021\", \"051\")\ndept = c(\"Emergency\", \"Cardiology\", \"Neurology\",\n         \"Anesthesia\", \"Surgery\", \"Psychiatry\")\npaste(id, dept)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"001 Emergency\"  \"010 Cardiology\" \"018 Neurology\"  \"020 Anesthesia\"\n[5] \"021 Surgery\"    \"051 Psychiatry\"\n```\n\n\n:::\n:::\n\n\n`paste0()` is an alias for the commonly used `paste(..., sep = \"\")`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste0(id, dept)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"001Emergency\"  \"010Cardiology\" \"018Neurology\"  \"020Anesthesia\"\n[5] \"021Surgery\"    \"051Psychiatry\"\n```\n\n\n:::\n:::\n\n\nAs with other vectorized operations, value recycling can be very convenient. In the \nexample below, the shorter vector (i.e. \"Feature\", a character vector of length 1) is\nrecycled to match the length of the longest vector (1:10).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste0(\"Feature_\", 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Feature_1\"  \"Feature_2\"  \"Feature_3\"  \"Feature_4\"  \"Feature_5\" \n [6] \"Feature_6\"  \"Feature_7\"  \"Feature_8\"  \"Feature_9\"  \"Feature_10\"\n```\n\n\n:::\n:::\n\n\nThe argument `collapse` helps output a *single* character object after \ncombining with some string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste0(\"Feature_\", 1:10, collapse = \", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9, Feature_10\"\n```\n\n\n:::\n:::\n\n\n## Common string utilities\n\n### Get number of characters in element with `nchar()`: \n\n`nchar()` counts the number of characters in each **element** of a character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", \"bb\", \"ccc\")\nnchar(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n### Extract/replace substring with `substr()`: \n\n`substr()` allows you to get and set individual (literal) characters from a \ncharacter vector, by position.\n\nFor example, extract the first three characters of each character element as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"001Emergency\", \"010Cardiology\", \"018Neurology\", \n       \"020Anesthesia\", \"021Surgery\", \"051Psychiatry\")\nsubstr(x, start = 1, stop = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"001\" \"010\" \"018\" \"020\" \"021\" \"051\"\n```\n\n\n:::\n:::\n\n\nNeither `start` nor `stop` need to be valid character positions.\n\nFor example, if you want to get all characters from the fourth one to the last \none, you can specify a very large `stop` as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubstr(x, 4, 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Emergency\"  \"Cardiology\" \"Neurology\"  \"Anesthesia\" \"Surgery\"   \n[6] \"Psychiatry\"\n```\n\n\n:::\n:::\n\n\nIf you start with too high an index, you end up with empty strings:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubstr(x, 20, 24)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"\" \"\" \"\" \"\" \"\" \"\"\n```\n\n\n:::\n:::\n\n\n**Note:** `substring()` is also available, with similar syntax to `substr()`: \n(first, last) instead of (start, stop). It is available for compatibility with S \n- check its source code to see how it's an alias for `substr()`.\n\nTo replace the first three letters, use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Jan_1987\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Jan_1987\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsubstr(x, 1, 3) <- \"Feb\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Feb_1987\"\n```\n\n\n:::\n:::\n\n\nNote that if the replacement is longer, it is \"cropped\" to the length of the \nsubstring being replaced:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubstr(x, 1, 3) <- \"April\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Apr_1987\"\n```\n\n\n:::\n:::\n\n\n### Split strings with `strsplit()`: \n\n`strsplit()` allows you to split a character vector's elements based on any \ncharacter or [regular expression](#regex).\n\nFor example, extract individual words by splitting a sentence on each space character:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"This is one sentence\"\nstrsplit(x, \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"This\"     \"is\"       \"one\"      \"sentence\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"14,910\"\nstrsplit(x, \",\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"14\"  \"910\"\n```\n\n\n:::\n:::\n\n\nAs with all functions, you can compose multiple string operations in complex ways, and as\nwith all function compositions remember to build and test them step-by-step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"1,950\", \"2,347\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1,950\" \"2,347\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(strsplit(x, \",\"), \\(i) \n  paste(i, c(\"thousand\", \"dollars\"), collapse = \" and \"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"1 thousand and 950 dollars\"\n\n[[2]]\n[1] \"2 thousand and 347 dollars\"\n```\n\n\n:::\n:::\n\n\n## String formatting\n\n### Change case with `toupper()` and `tolower()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeatures <- c(\"id\", \"age\", \"sex\", \"sbp\", \"dbp\", \"hct\", \"urea\", \"creatinine\")\nfeatures\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"id\"         \"age\"        \"sex\"        \"sbp\"        \"dbp\"       \n[6] \"hct\"        \"urea\"       \"creatinine\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfeatures_upper <- toupper(features)\nfeatures_upper\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ID\"         \"AGE\"        \"SEX\"        \"SBP\"        \"DBP\"       \n[6] \"HCT\"        \"UREA\"       \"CREATININE\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfeatures_lower <- tolower(features_upper)\nfeatures_lower\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"id\"         \"age\"        \"sex\"        \"sbp\"        \"dbp\"       \n[6] \"hct\"        \"urea\"       \"creatinine\"\n```\n\n\n:::\n:::\n\n\n### Convert to Title Case\n\nThe `tools` package comes with the base R installation, but is not loaded at startup,\nbecause it contains rather specialized functions for package development, administration,\nand documentation. However, it includes the `toTitleCase()` function, which can be handy\nfor formatting variable names, e.g. before plotting, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeatures <- c(\"full name\", \"admission type\", \"attending name\", \"date of admission\")\ntools::toTitleCase(features)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Full Name\"         \"Admission Type\"    \"Attending Name\"   \n[4] \"Date of Admission\"\n```\n\n\n:::\n:::\n\n\n### Abbreviate\n\n`abbreviate()` allows reducing character vector elements to short, unique \nabbreviations of a minimum length (defaults to 4). For example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Emergency\", \"Cardiology\", \"Surgery\", \"Anesthesia\", \n       \"Neurology\", \"Psychiatry\", \"Clinical Psychology\")\nabbreviate(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          Emergency          Cardiology             Surgery          Anesthesia \n             \"Emrg\"              \"Crdl\"              \"Srgr\"              \"Anst\" \n          Neurology          Psychiatry Clinical Psychology \n             \"Nrlg\"              \"Psyc\"              \"ClnP\" \n```\n\n\n:::\n\n```{.r .cell-code}\nabbreviate(x, minlength = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          Emergency          Cardiology             Surgery          Anesthesia \n             \"Emrg\"              \"Crdl\"              \"Srgr\"              \"Anst\" \n          Neurology          Psychiatry Clinical Psychology \n             \"Nrlg\"              \"Psyc\"              \"ClnP\" \n```\n\n\n:::\n\n```{.r .cell-code}\nabbreviate(x, minlength = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          Emergency          Cardiology             Surgery          Anesthesia \n            \"Emrgn\"             \"Crdlg\"             \"Srgry\"             \"Ansth\" \n          Neurology          Psychiatry Clinical Psychology \n            \"Nrlgy\"             \"Psych\"             \"ClncP\" \n```\n\n\n:::\n:::\n\n\n## Pattern matching\n\nA very common task in programming is to find +/- replace string patterns in a \nvector of strings.  \n<br><br>\n- `grep()` and `grepl()` help find strings that contain a given pattern.  \n- `sub()` and `gsub()` help find and replace strings.\n\n### `grep()`: Get **integer** index of elements that match a pattern {#grep}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"001Age\", \"002Sex\", \"010Temp\", \"014SBP\", \n       \"018Hct\", \"022PFratio\", \"030GCS\", \"112SBP-DBP\")\ngrep(pattern = \"SBP\", x = x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 8\n```\n\n\n:::\n:::\n\n\n`grep()`'s `value` argument, which defaults to `FALSE`, allows returning the \nmatched string itself (the value of the element) instead of its integer index, e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"SBP\", x, value = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"014SBP\"     \"112SBP-DBP\"\n```\n\n\n:::\n:::\n\n\n### `grepl()`: Get **logical** index of elements that match a pattern {#grepl}\n\n`grepl()` is similar to `grep()`, but returns a logical index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"SBP\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n### `sub()`: Replace **first** match of a pattern {#sub}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"The most important variable was PF ratio. Other significant variables are listed \nin the supplementary information.\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The most important variable was PF ratio. Other significant variables are listed \\nin the supplementary information.\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsub(pattern = \"variable\", replacement = \"feature\", x = x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The most important feature was PF ratio. Other significant variables are listed \\nin the supplementary information.\"\n```\n\n\n:::\n:::\n\n\n`sub()` is vectorized and \"first match\" refers to each element of a character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"var 1, var 2\", \"var 3, var 4\")\nsub(\"var\", \"feat\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"feat 1, var 2\" \"feat 3, var 4\"\n```\n\n\n:::\n:::\n\n\n### `gsub()`: Replace **all** matches of a pattern {#gsub}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"The most important variable was P/F ratio. Other significant variables are listed in the supplementary information.\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The most important variable was P/F ratio. Other significant variables are listed in the supplementary information.\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngsub(pattern = \"variable\", replacement = \"feature\", x = x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The most important feature was P/F ratio. Other significant features are listed in the supplementary information.\"\n```\n\n\n:::\n:::\n\n\n\"All matches\" means all matches across all elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"var 1, var 2\", \"var 3, var 4\")\ngsub(\"var\", \"feat\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"feat 1, feat 2\" \"feat 3, feat 4\"\n```\n\n\n:::\n:::\n\n\n### Match one or more patterns\n\nYou can use a vertical bar (`|`) in the pattern string to match one of multiple patterns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Emergency\", \"Cardiology\", \"Neurology\", \"Anesthesia\", \n       \"Surgery\", \"Psychiatry\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"Cardio|Neuro\", x, value = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Cardiology\" \"Neurology\" \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"Emerg|Surg|Anesth\", x, value = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Emergency\"  \"Anesthesia\" \"Surgery\"   \n```\n\n\n:::\n:::\n\n\n## Regular expressions {#regex}\n\nRegular expressions allow you to perform flexible pattern matching. For \nexample, you can look for a pattern specifically at the beginning or the end of \na word, or for a variable pattern with certain characteristics.\n<br><br>\nRegular expressions are very powerful and heavily used. They exist in multiple \nprogramming languages - with many similarities and some differences in their \nsyntax.\n<br><br>\nThere are many rules in defining regular expressions and they take a little getting \nused to. You can read the R manual by typing `?base::regex`.\n<br><br>\nSome of the most important rules are listed below:\n\n### Match a pattern at the beginning of a line/string with `^` and `\\\\<`\n\nUse the caret sign `^` in the **beginning** of a pattern to only match strings \nthat begin with that pattern.  \n\nPattern `012` matches both 2nd and 3rd elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"001_xyz_993\", \"012_qwe_764\", \"029_aqw_012\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"001_xyz_993\" \"012_qwe_764\" \"029_aqw_012\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"012\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3\n```\n\n\n:::\n:::\n\n\nBy adding `^` or `\\\\<`, only the 2nd element in our character vector matches:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"^012\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"\\\\<012\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n### Match a pattern at the end of a line/string with `$` and `\\\\>`\n\nThe dollar sign `$` is used at the **end** of a pattern to only match strings \nwhich end with this pattern:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"001_xyz_993\" \"012_qwe_764\" \"029_aqw_012\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"012$\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"012\\\\>\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"1one\", \"2one\", \"3two\", \"3three\")\ngrep(\"one$\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"one\\\\>\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n:::\n\n\n### Match any character with `.`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"e.X\", c(\"eX\", \"enX\", \"ennX\", \"ennnX\", \"ennnnX\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n### Match preceding character one or more times with `+`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"en+X\", c(\"eX\", \"enX\", \"ennX\", \"ennnX\", \"ennnnX\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n### Match preceding character `n` times with `{n}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"en{2}X\", c(\"eX\", \"enX\", \"ennX\", \"ennnX\", \"ennnnX\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n### Match preceding character `n` or more times with `{n,}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"en{2,}X\", c(\"eX\", \"enX\", \"ennX\", \"ennnX\", \"ennnnX\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n:::\n\n\n### Match preceding character at least `n` times and no more than `m` times with `{n,m}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\"en{2,3}X\", c(\"eX\", \"enX\", \"ennX\", \"ennnX\", \"ennnnX\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n:::\n\n\n### Character classes {#characterclasses}\n\nYou can define a set of characters to be matched using square brackets. Any \nnumber of the characters in the set will be matched.\n\nFor example match and replace `$` and/or `@` with an underscore:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Feat1$alpha\", \"Feat2$gamma@5\", \"Feat9@zeta2\")\ngsub(\"[$@]\", \"_\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Feat1_alpha\"   \"Feat2_gamma_5\" \"Feat9_zeta2\"  \n```\n\n\n:::\n:::\n\n\n#### Predefined character classes\n\nA number of character classes are predefined. Perhaps confusingly, they are \nthemselves surrounded by brackets and to use them as a character class, you \nneed a second set of brackets around them. Some of the most common ones \ninclude:  \n\n* `[:alnum:]`: alphanumeric, i.e. all letters and numbers\n* `[:alpha:]`: all letters\n* `[:digit:]`: all numbers\n* `[:lower:]`: all lowercase letters\n* `[:upper:]`: all uppercase letters\n* `[:punct:]`: all punctuation characters (! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` { | } ~.)\n* `[:blank:]`: all spaces and tabs\n* `[:space:]`: all spaces, tabs, newline characters, and some more\n\nLet's look at some examples using them.\n\nHere we use `[:digit:]` to remove all numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"001Emergency\", \"010Cardiology\", \"018Neurology\", \"020Anesthesia\", \n       \"021Surgery\", \"051Psychiatry\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"001Emergency\"  \"010Cardiology\" \"018Neurology\"  \"020Anesthesia\"\n[5] \"021Surgery\"    \"051Psychiatry\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngsub(\"[[:digit:]]\", \"\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Emergency\"  \"Cardiology\" \"Neurology\"  \"Anesthesia\" \"Surgery\"   \n[6] \"Psychiatry\"\n```\n\n\n:::\n:::\n\n\nWe can use `[:alpha:]` to remove all letters instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsub(\"[[:alpha:]]\", \"\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"001\" \"010\" \"018\" \"020\" \"021\" \"051\"\n```\n\n\n:::\n:::\n\n\nWe can use a caret `^` in the beginning of a character class to match any \ncharacter *not* in the character set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"001$Emergency\", \"010@Cardiology\", \"018*Neurology\", \"020!Anesthesia\", \n       \"021!Surgery\", \"051*Psychiatry\")\ngsub(\"[^[:alnum:]]\", \"_\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"001_Emergency\"  \"010_Cardiology\" \"018_Neurology\"  \"020_Anesthesia\"\n[5] \"021_Surgery\"    \"051_Psychiatry\"\n```\n\n\n:::\n:::\n\n\n### Match from multiple character classes\n\nSame as above, you can use `|` to match from multiple character classes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"123#$%alphaBeta\")\ngsub(\"[[:digit:]|[:punct:]]\", \"\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"alphaBeta\"\n```\n\n\n:::\n:::\n\n\n::: callout-note\nFor more information on regular expressions, \nstart by reading the built-in documentation: `?regex`.\n:::\n\n### Escaping metacharacters\n\nMetacharacters are characters that have a special meaning within a regular \nexpression. They include:\n\n`. \\ | ( ) [ { ^ $ * + ?`.  \n\nFor example, we have seen above that the period matches any character and the \nsquare brackets are used to define [character classes](#characterclasses)\nIf you want to match one of these characters itself, you must \"escape\" it using \na double backslash. Escaping a character simply means \"this is not part of a \nregular expression, match it as is\".\n<br><br>\nFor example, to match a period (`.`) and replace it with underscores:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"systolic.blood.pressure\", \"diastolic.blood.pressure\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"systolic.blood.pressure\"  \"diastolic.blood.pressure\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngsub(\"\\\\.\", \"_\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"systolic_blood_pressure\"  \"diastolic_blood_pressure\"\n```\n\n\n:::\n:::\n\n\nIf we didn't escape the period above, it would have matched *any* character:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsub(\".\", \"_\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"_______________________\"  \"________________________\"\n```\n\n\n:::\n:::\n\n\nAnother example, include an escaped metacharacter within a regular expression. \nIn the example below we want to remove everything up to and including the \ndollar sign:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"df$ID\", \"df$Age\")\ngsub(\".*\\\\$\", \"\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ID\"  \"Age\"\n```\n\n\n:::\n:::\n\n\nOur regular expression `.*\\\\$`, decomposed:\n\n- `.`: match any character\n- `.*`: match any character any number of times\n- `.*\\\\$`: match any character any number of times till you find a dollar sign\n\nIf we had not escaped the `$`, it wouldn't have worked:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsub(\".*$\", \"\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"\" \"\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}