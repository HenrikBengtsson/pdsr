{
  "hash": "16afecf0ba0ff806d680fbb3f2fcd53a",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk: \n    comment: ''\n---\n\n# Basic operations {#basicops}\n\nFirst, before even learning about data types and structures, it may be worth \nlooking at some of the basic mathematical and statistical operations in R.\n\n## Mathematical operations\n\nWe use the assignment operator `<-` to assign values to variables `x` and `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 3\n```\n:::\n\n\nStandard arithmetic operations are as expected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13\n```\n\n\n:::\n\n```{.r .cell-code}\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30\n```\n\n\n:::\n\n```{.r .cell-code}\nx / y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.333333\n```\n\n\n:::\n:::\n\nExponentiation uses `^`:\n(The caret (`^`) is likely the most common but not the only symbol used for \nexponentiation across programming languages)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx^3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000\n```\n\n\n:::\n:::\n\n\nSquare root is `sqrt()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(81)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\nNatural logs with `log()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.484907\n```\n\n\n:::\n:::\n\n\nBase 10 log with `log10()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog10(1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nExponential function with `exp()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.718282\n```\n\n\n:::\n:::\n\n\nInteger division i.e. *Divide and forget the remainder*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx %/% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\ni.e. how many times the denominator fits in the numerator, without taking \nfractions of the denominator. It can be applied on decimals the same way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n9.5 %/% 3.1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nModulo operation i.e. *Divide and return just the remainder*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx %% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- (-10:10)[-11]\ny <- sample((-10:10)[-11], 20)\nx - (x %/% y) * y == x %% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE\n```\n\n\n:::\n:::\n\n\nTrigonometric functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncos(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -0.8390715 -0.9111303 -0.1455000  0.7539023  0.9601703  0.2836622\n [7] -0.6536436 -0.9899925 -0.4161468  0.5403023  0.5403023 -0.4161468\n[13] -0.9899925 -0.6536436  0.2836622  0.9601703  0.7539023 -0.1455000\n[19] -0.9111303 -0.8390715\n```\n\n\n:::\n\n```{.r .cell-code}\nsin(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0.5440211 -0.4121185 -0.9893582 -0.6569866  0.2794155  0.9589243\n [7]  0.7568025 -0.1411200 -0.9092974 -0.8414710  0.8414710  0.9092974\n[13]  0.1411200 -0.7568025 -0.9589243 -0.2794155  0.6569866  0.9893582\n[19]  0.4121185 -0.5440211\n```\n\n\n:::\n\n```{.r .cell-code}\ntan(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -0.6483608  0.4523157  6.7997115 -0.8714480  0.2910062  3.3805150\n [7] -1.1578213  0.1425465  2.1850399 -1.5574077  1.5574077 -2.1850399\n[13] -0.1425465  1.1578213 -3.3805150 -0.2910062  0.8714480 -6.7997115\n[19] -0.4523157  0.6483608\n```\n\n\n:::\n:::\n\n\nSee `?cos` for more specialized trigonometric functions and details.\n\n## Logical operations\n\nLogical AND: `&`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT & T\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nT & F\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nLogical OR: `|`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT | F\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nLogical negation: `!`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- TRUE\n!x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nExclusive OR: `xor()`  \nXOR evaluates to TRUE when two logicals are different,  \ni.e. one or the other is TRUE but not both.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(T, T, T, F, F, F)\nb <- c(F, F, T, F, T, T)\na & b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\na | b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\nTest all elements of an object are TRUE with `all()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nTest if any element is TRUE with `any()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Common statistical operations\n\nFirst, let's use the `rnorm()` function to draw 200 numbers at random from a \nnormal distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(200)\n```\n:::\n\n\n### Descriptive statistics\n\nmean, median, standard deviation, minimum, maximum, and range:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.04854619\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.07156896\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.171549\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3.237767\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.567451\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3.237767  3.567451\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-3.23777 -0.71513  0.07157  0.04855  0.82985  3.56745 \n```\n\n\n:::\n:::\n\n\n### Sampling\n\nR's `sample()` allows you to samples elements of an \n[R object](#sec-datastructures) with or without replacement:\n\nBy default, the `replace` argument is set to `FALSE`, i.e. sampling is \nperformed without replacement and you can request a sample size up to the\nlength of the object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 21:30\nsample(x, size = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21 26 28 23 22\n```\n\n\n:::\n:::\n\n\n`size` is the second argument and its name can therefore be omitted if it is the\nsecond value you pass to `sample()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(x, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 21 25 27 26 29 30 24 28 23 22\n```\n\n\n:::\n:::\n\n\nSetting `replace = TRUE` performs sampling with replacement and you can set \nsize to any positive integer, including values larger than the length of the\ninput:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(x, 100, replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 30 25 24 22 30 27 28 29 28 30 28 28 26 29 23 30 30 22 22 29 21 25 30 30 23\n [26] 23 22 30 30 29 21 30 22 29 30 28 28 25 21 25 30 22 24 28 21 25 27 24 27 30\n [51] 28 29 30 27 30 26 21 25 23 30 28 21 29 21 22 26 27 28 26 26 25 29 21 29 21\n [76] 29 30 23 30 26 28 26 26 26 25 22 29 26 30 30 24 28 23 21 29 21 26 24 27 22\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}