{
  "hash": "7f42803273a44e07af24fd0cbcae4846",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk: \n    comment: ''\n---\n\n# Basic operations {#basicops}\n\nFirst, before even learning about data types and structures, it may be worth \nlooking at some of the basic mathematical and statistical operations in R.\n\n## Mathematical operations\n\nWe use the assignment operator `<-` to assign values to variables `x` and `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 3\n```\n:::\n\n\nStandard arithmetic operations are as expected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n\n```{.r .cell-code}\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 30\n```\n:::\n\n```{.r .cell-code}\nx / y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.333333\n```\n:::\n:::\n\nExponentiation uses `^`:\n(The caret (`^`) is likely the most common but not the only symbol used for \nexponentiation across programming languages)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx^3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n\n\nSquare root is `sqrt()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(81)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\nNatural logs with `log()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.484907\n```\n:::\n:::\n\n\nBase 10 log with `log10()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog10(1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nExponential function with `exp()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.718282\n```\n:::\n:::\n\n\nInteger division i.e. *Divide and forget the remainder*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx %/% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\ni.e. how many times the denominator fits in the numerator, without taking \nfractions of the denominator. It can be applied on decimals the same way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n9.5 %/% 3.1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nModulo operation i.e. *Divide and return just the remainder*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx %% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- (-10:10)[-11]\ny <- sample((-10:10)[-11], size = 20)\nx - (x %/% y) * y == x %% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE\n```\n:::\n:::\n\n\nTrigonometric functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncos(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -0.8390715 -0.9111303 -0.1455000  0.7539023  0.9601703  0.2836622\n [7] -0.6536436 -0.9899925 -0.4161468  0.5403023  0.5403023 -0.4161468\n[13] -0.9899925 -0.6536436  0.2836622  0.9601703  0.7539023 -0.1455000\n[19] -0.9111303 -0.8390715\n```\n:::\n\n```{.r .cell-code}\nsin(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0.5440211 -0.4121185 -0.9893582 -0.6569866  0.2794155  0.9589243\n [7]  0.7568025 -0.1411200 -0.9092974 -0.8414710  0.8414710  0.9092974\n[13]  0.1411200 -0.7568025 -0.9589243 -0.2794155  0.6569866  0.9893582\n[19]  0.4121185 -0.5440211\n```\n:::\n\n```{.r .cell-code}\ntan(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -0.6483608  0.4523157  6.7997115 -0.8714480  0.2910062  3.3805150\n [7] -1.1578213  0.1425465  2.1850399 -1.5574077  1.5574077 -2.1850399\n[13] -0.1425465  1.1578213 -3.3805150 -0.2910062  0.8714480 -6.7997115\n[19] -0.4523157  0.6483608\n```\n:::\n:::\n\n\nSee `?cos` for more specialized trigonometric functions and details.\n\n## Logical operations\n\nLogical AND: `&`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nLogical OR: `|`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nLogical negation: `!`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- TRUE\n!x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nExclusive OR: `xor()`  \nXOR evaluates to TRUE when two logicals are different,  \ni.e. one or the other is TRUE but not both.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE)\nb <- c(FALSE, FALSE, TRUE, FALSE, TRUE, TRUE)\na & b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\na | b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\nxor(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n```\n:::\n:::\n\n\nTest all elements of an object are TRUE with `all()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nTest if any element is TRUE with `any()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Common statistical operations\n\nFirst, let's use the `rnorm()` function to draw 200 numbers at random from a \nnormal distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(200)\n```\n:::\n\n\n### Descriptive statistics\n\nmean, median, standard deviation, minimum, maximum, and range:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.02548709\n```\n:::\n\n```{.r .cell-code}\nmedian(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.1005019\n```\n:::\n\n```{.r .cell-code}\nsd(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.011318\n```\n:::\n\n```{.r .cell-code}\nmin(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3.340491\n```\n:::\n\n```{.r .cell-code}\nmax(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.631032\n```\n:::\n\n```{.r .cell-code}\nrange(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3.340491  2.631032\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-3.34049 -0.53079 -0.10050  0.02549  0.68167  2.63103 \n```\n:::\n:::\n\n\n### Sampling\n\nR's `sample()` allows you to samples elements of an \n[R object](#sec-datastructures) with or without replacement:\n\nBy default, the `replace` argument is set to `FALSE`, i.e. sampling is \nperformed without replacement and you can request a sample size up to the\nlength of the object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 21:30\nsample(x, size = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 30 21 28 26 29\n```\n:::\n:::\n\n\n`size` is the second argument and its name can therefore be omitted if it is the\nsecond value you pass to `sample()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(x, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 23 21 28 27 25 26 30 24 29 22\n```\n:::\n:::\n\n\nSetting `replace = TRUE` performs sampling with replacement and you can set \nsize to any positive integer, including values larger than the length of the\ninput:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(x, size = 100, replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 26 26 27 28 27 22 23 25 21 25 24 27 28 23 24 26 26 22 27 29 26 25 21 24 30\n [26] 30 22 27 29 26 24 25 30 21 25 23 22 25 23 25 23 25 29 23 25 26 27 21 30 26\n [51] 24 23 24 25 24 27 21 24 27 27 24 23 21 26 29 28 29 29 22 21 29 27 26 22 27\n [76] 25 24 24 28 24 29 27 24 28 24 21 23 25 27 21 28 22 30 26 27 24 28 23 21 30\n```\n:::\n:::\n",
    "supporting": [
      "BasicOps_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}