{
  "hash": "72ad3e3642d4d37d39836e5277ef4348",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk: \n    comment: ''\n    error: true\n---\n\n# Loop Functions {#sec-loopfns}\n\nLoop functions are some of the most widely used R functions. They replace \nlonger expressions created with a `for` loop, for example.  \nThey can result in more compact and readable code.  \n\n| Function   | Description\n|-----------:|----------------------------------------------------------------:|\n| `apply()`  | Apply function over array margins (i.e. over one or more dimensions)\n| `lapply()` | Return a *list* where each element is the result of applying a function to each element of the input\n| `sapply()` | Same as `lapply()`, but returns the simplest possible R object (instead of always returning a list)\n| `vapply()` | Same as `sapply()`, but with a pre-specified return type: this is safer and may also be faster\n| `tapply()` | Apply a function to elements of groups defined by a factor\n| `mapply()` | Multivariate `sapply()`: Apply a function using the 1st elements of the inputs vectors, then using the 2nd, 3rd, etc.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![`*apply()` function family summary (Best to read through this chapter first and then refer back to this figure)](./R_applyfam.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## `apply()` {#apply}\n\n::: callout-tip\n`apply()` applies a function over one or more dimensions of an array of 2 \ndimensions or more (this includes matrices) or a data frame:\n\n`apply(array, MARGIN, FUN)`\n:::\n\n`MARGIN` can be an integer vector or character indicating the dimensions over \nwhich 'FUN' will be applied.\n\nBy convention, rows come first (just like in [indexing](#indexing)), therefore:\n\n- `MARGIN = 1`: apply function on each ***row***\n- `MARGIN = 2`: apply function on each ***column***\n\n\nLet's create an example dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(Age = rnorm(50, mean = 42, sd = 8),\n                  Weight = rnorm(50, mean = 80, sd = 10),\n                  Height = rnorm(50, mean = 1.72, sd = .14),\n                  SBP = rnorm(50, mean = 134, sd = 4))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age   Weight   Height      SBP\n1 42.49072 88.49907 1.846964 139.2092\n2 46.39626 71.03311 1.879580 132.0072\n3 36.46471 70.61813 1.769191 129.4022\n4 37.82188 80.01291 1.864163 134.0079\n5 54.56728 82.35835 1.727475 129.1432\n6 47.88655 76.11747 1.611482 136.5716\n```\n:::\n:::\n\n\nLet's calculate the mean value of each column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_column_mean <- apply(dat, MARGIN = 2, FUN = mean) \ndat_column_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP \n 40.835738  79.042210   1.722052 133.520406 \n```\n:::\n:::\n\n\n::: callout-tip\nHint: It is possibly easiest to think of the \"MARGIN\" as the \n***dimension you want to keep***.  \nIn the above case, we want the mean for each variable, i.e. we want to keep \ncolumns and collapse rows.\n:::\n\nPurely as an example to understand what `apply()` does, here is the equivalent\nprocedure using a for-loop. You notice how much more code is needed, and why\n`apply()` and similar functions might be very convenient for many different \ntasks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_column_mean <- numeric(ncol(dat))\nnames(dat_column_mean) <- names(dat)\n\nfor (i in seq(dat)) {\n  dat_column_mean[i] <- mean(dat[, i])\n}\ndat_column_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP \n 40.835738  79.042210   1.722052 133.520406 \n```\n:::\n:::\n\n\nLet's create a different example dataset, where we record weight at multiple\ntimepoints:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- data.frame(ID = seq(8001, 8020),\n                   Weight_week_1 = rnorm(20, mean = 110, sd = 10))\ndat2$Weight_week_3 <- dat2$Weight_week_1 + rnorm(20, mean = -2, sd = 1)\ndat2$Weight_week_5 <- dat2$Weight_week_3 + rnorm(20, mean = -3, sd = 1.1)\ndat2$Weight_week_7 <- dat2$Weight_week_5 + rnorm(20, mean = -1.8, sd = 1.3)\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     ID Weight_week_1 Weight_week_3 Weight_week_5 Weight_week_7\n1  8001     119.40550     117.68586     114.03822     110.62932\n2  8002      96.96934      94.15560      91.86897      90.24754\n3  8003     116.26889     116.02828     113.10216     111.57683\n4  8004     111.19885     108.25437     103.66022     102.94477\n5  8005     106.62353     104.03810     100.83267      99.49498\n6  8006      97.97112      96.38202      94.54538      93.08483\n7  8007     103.77771     100.14995      96.84112      95.55208\n8  8008     105.25577     103.52251     101.71702      97.19381\n9  8009     115.76227     111.04959     109.57031     107.98290\n10 8010     128.62155     126.45202     125.15781     122.49209\n11 8011     106.09324     103.65102      98.98631      95.95421\n12 8012     104.88479     101.39591      97.03887      95.09932\n13 8013     124.72623     123.98823     120.42261     119.28063\n14 8014     130.08313     128.01757     122.62800     120.98040\n15 8015     119.84346     117.55325     116.37828     113.10157\n16 8016     117.57234     115.68321     113.68792     111.63403\n17 8017     108.78155     105.97457     104.68627     105.11501\n18 8018     102.01848     100.94626      97.61814      96.44862\n19 8019      99.80349      98.01862      96.19582      93.29062\n20 8020      98.32738      96.52209      94.51567      92.45491\n```\n:::\n:::\n\n\nLet's get the mean weight per week:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(dat2[, -1], 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWeight_week_1 Weight_week_3 Weight_week_5 Weight_week_7 \n     110.6994      108.4735      105.6746      103.7279 \n```\n:::\n:::\n\n\nLet's get the mean weight per individual across all weeks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(dat2[, -1], 1, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 115.43973  93.31036 114.24404 106.51455 102.74732  95.49584  99.08022\n [8] 101.92228 111.09127 125.68087 101.17120  99.60472 122.10442 125.42727\n[15] 116.71914 114.64438 106.13935  99.25787  96.82714  95.45501\n```\n:::\n:::\n\n\n::: callout-caution\n`apply()` converts 2-dimensional objects to matrices before applying the\nfunction. Therefore, if applied on a data.frame with mixed data types, it will\nbe coerced to a character matrix.\n\nThis is explained in the `apply()` documentation under \"Details\":\n\n*\"If X is not an array but an object of a class with a non-null dim value (such as a data frame), apply attempts to coerce it to an array via as.matrix if it is two-dimensional (e.g., a data frame) or via as.array.\"*\n:::\n\nBecause of the above, see what happens when you use apply on the `iris` data.frame which contains 4 numeric variables and one factor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napply(iris, 2, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n \"character\"  \"character\"  \"character\"  \"character\"  \"character\" \n```\n:::\n:::\n\n\n## `lapply()` {#lapply}\n\n::: callout-tip\n`lapply()` applies a **function** on **each element of its input** and returns \na **list** of the outputs.  \n:::\n\nNote: The 'elements' of a data frame are its columns (remember, a data frame is \na list with equal-length elements). The 'elements' of a matrix are each cell \none by one, by column. Therefore, unlike `apply()`, `lapply()` has a very \ndifferent effect on a data frame and a matrix. `lapply()` is commonly used to \niterate over the columns of a data frame.\n\n::: callout-tip\n`lapply()` is the only function of the `*apply()` family that always returns a \nlist.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_median <- lapply(dat, median)\ndat_median\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Age\n[1] 41.20526\n\n$Weight\n[1] 78.82495\n\n$Height\n[1] 1.723279\n\n$SBP\n[1] 133.1141\n```\n:::\n:::\n\n\nTo understand what `lapply()` does, here is the equivalent for-loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_median <- vector(\"list\", length = 4)\nnames(dat_median) <- colnames(dat)\nfor (i in 1:4) {\n  dat_median[[i]] <- median(dat[, i])\n}\ndat_median\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Age\n[1] 41.20526\n\n$Weight\n[1] 78.82495\n\n$Height\n[1] 1.723279\n\n$SBP\n[1] 133.1141\n```\n:::\n:::\n\n\n## `sapply()` {#sapply}\n\n`sapply()` is an alias for `lapply()`, followed by a call to `simplify2array()`.  \n(Check the source code for `sapply()` by typing `sapply` at the console).  \n\n\n::: callout-note\nUnlike `lapply()`, the output of `sapply()` is **variable**: \nit is the simplest R  object that can hold the data type(s) resulting from the \noperations, i.e. a vector, matrix, data frame, or list.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_median <- sapply(dat, median)\ndat_median\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP \n 41.205263  78.824945   1.723279 133.114084 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_summary <- data.frame(Mean = sapply(dat, mean),\n                           SD = sapply(dat, sd))\ndat_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Mean        SD\nAge     40.835738 7.1782328\nWeight  79.042210 8.2969047\nHeight   1.722052 0.1238645\nSBP    133.520406 4.0445137\n```\n:::\n:::\n\n\n### Example: Get index of numeric variables\n\nLet's use `sapply()` to get an index of numeric columns in dat2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ID Weight_week_1 Weight_week_3 Weight_week_5 Weight_week_7\n1 8001     119.40550     117.68586     114.03822     110.62932\n2 8002      96.96934      94.15560      91.86897      90.24754\n3 8003     116.26889     116.02828     113.10216     111.57683\n4 8004     111.19885     108.25437     103.66022     102.94477\n5 8005     106.62353     104.03810     100.83267      99.49498\n6 8006      97.97112      96.38202      94.54538      93.08483\n```\n:::\n:::\n\n\nlogical index of numeric columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumidl <- sapply(dat2, is.numeric)\n```\n:::\n\n\ninteger index of numeric columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumidi <- which(sapply(dat2, is.numeric))\n```\n:::\n\n\n## `vapply()` {#vapply}\n\nMuch less commonly used (possibly *underused*) than `lapply()` or `sapply()`, \n`vapply()` allows you to specify what the expected output looks like - for \nexample a numeric vector of length 2, a character vector of length 1.\n\nThis can have two advantages:\n\n- It is safer against errors\n- It will sometimes be a little faster\n\nYou add the argument `FUN.VALUE` which must be of the correct **type** and \n**length** of the expected result ***of each iteration***.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(dat, median, FUN.VALUE = .1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP \n 41.205263  78.824945   1.723279 133.114084 \n```\n:::\n:::\n\n\nHere, each iteration returns the median of each column, i.e. a numeric vector \nof length 1.\n\nTherefore `FUN.VALUE` can be any numeric scalar.\n\nFor example, if we instead returned the range of each column, `FUN.VALUE` \nshould be a numeric vector of length 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(dat, range, FUN.VALUE = rep(.1, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Age   Weight   Height      SBP\n[1,] 24.99508 61.64038 1.473344 122.6332\n[2,] 57.50974 98.30305 2.058724 142.9150\n```\n:::\n:::\n\n\nIf `FUN.VALUE` does not match the returned value, we get an informative error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(dat, range, FUN.VALUE = .1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in vapply(dat, range, FUN.VALUE = 0.1): values must be length 1,\n but FUN(X[[1]]) result is length 2\n```\n:::\n:::\n\n\n## `tapply()` {#tapply}\n\n`tapply()` is one way (of many) to apply a function on **subgroups of data** \nas defined by one or more factors.  \nIn the following example, we calculate the mean Sepal.Length by species on the \niris dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$Group <- factor(sample(c(\"A\", \"B\", \"C\"), size = 50, replace = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_Age_by_Group <- tapply(dat[[\"Age\"]], dat[\"Group\"], mean)\nmean_Age_by_Group\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGroup\n       A        B        C \n41.63731 37.99599 44.13921 \n```\n:::\n:::\n\n\nThe for-loop equivalent of the above is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- levels(dat$Group)\nmean_Age_by_Group <- vector(\"numeric\", length = length(groups))\nnames(mean_Age_by_Group) <- groups\n\nfor (i in seq(groups)) {\n  mean_Age_by_Group[i] <- \n    mean(dat$Age[dat$Group == groups[i]])\n}\nmean_Age_by_Group\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A        B        C \n41.63731 37.99599 44.13921 \n```\n:::\n:::\n\n\n## `mapply()` {#mapply}\n\nThe functions we have looked at so far work well when you iterating over \nelements of a single object.\n\n`mapply()` allows you to execute a function that accepts two or more inputs, \nsay `fn(x, z)` using the i-th element of each input, and will return:  \n`fn(x[1], z[1])`, `fn(x[2], z[2])`, ..., `fn(x[n], z[n])`\n\nLet's create a simple function that accepts two numeric arguments, and two \nvectors length 5 each:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraise <- function(x, power) x^power\nx <- 2:6\np <- 6:2\n```\n:::\n\n\nUse mapply to raise each `x` to the corresponding `p`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- mapply(raise, x, p)\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  64 243 256 125  36\n```\n:::\n:::\n\n\nThe above is equivalent to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- vector(\"numeric\", length = 5)\nfor (i in seq(5)) {\n  out[i] <- raise(x[i], p[i])\n}\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  64 243 256 125  36\n```\n:::\n:::\n\n\n## `*apply()`ing on matrices vs. data frames\n\nTo consolidate some of what was learned above, let's focus on the difference \nbetween working on a matrix vs. a data frame.  \nFirst, let's create a matrix and a data frame with the same data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\namat <- matrix(21:70, nrow = 10)\ncolnames(amat) <- paste0(\"Feature_\", 1:ncol(amat))\namat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Feature_1 Feature_2 Feature_3 Feature_4 Feature_5\n [1,]        21        31        41        51        61\n [2,]        22        32        42        52        62\n [3,]        23        33        43        53        63\n [4,]        24        34        44        54        64\n [5,]        25        35        45        55        65\n [6,]        26        36        46        56        66\n [7,]        27        37        47        57        67\n [8,]        28        38        48        58        68\n [9,]        29        39        49        59        69\n[10,]        30        40        50        60        70\n```\n:::\n\n```{.r .cell-code}\nadf <- as.data.frame(amat)\nadf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Feature_1 Feature_2 Feature_3 Feature_4 Feature_5\n1         21        31        41        51        61\n2         22        32        42        52        62\n3         23        33        43        53        63\n4         24        34        44        54        64\n5         25        35        45        55        65\n6         26        36        46        56        66\n7         27        37        47        57        67\n8         28        38        48        58        68\n9         29        39        49        59        69\n10        30        40        50        60        70\n```\n:::\n:::\n\n\nWe've seen that with `apply()` we specify the dimension to operate on and it \nworks the same way on both matrices and data frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(amat, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFeature_1 Feature_2 Feature_3 Feature_4 Feature_5 \n     25.5      35.5      45.5      55.5      65.5 \n```\n:::\n\n```{.r .cell-code}\napply(adf, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFeature_1 Feature_2 Feature_3 Feature_4 Feature_5 \n     25.5      35.5      45.5      55.5      65.5 \n```\n:::\n:::\n\n\nHowever, `sapply()` (and `lapply()`, `vapply()`) acts on ***each element*** of \nthe object, therefore it is not meaningful to pass a matrix to it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(amat, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45\n[26] 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70\n```\n:::\n:::\n\n\nThe above returns the mean of each element, i.e. the element itself, which is \nmeaningless.\n\nSince a data frame is a list, and its columns are its elements, it works great \nfor column operations on data frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(adf, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFeature_1 Feature_2 Feature_3 Feature_4 Feature_5 \n     25.5      35.5      45.5      55.5      65.5 \n```\n:::\n:::\n\n\nIf you want to use `sapply()` on a matrix, you could iterate over an integer \nsequence as shown in the previous section:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(1:ncol(amat), function(i) mean(amat[, i]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25.5 35.5 45.5 55.5 65.5\n```\n:::\n:::\n\n\nThis is shown to help emphasize the differences between the function and the \ndata structures. In practice, you would use `apply()` on a matrix.\n\n## Anonymous functions {#anonfns}\n\nAnonymous functions are just like regular functions but they are not assigned \nto an object - i.e. they are not \"named\".  \nThey are usually passed as arguments to other functions to be used once, hence \nno need to assign them.\n\nAnonymous functions are often used with the apply family of functions.  \n\nExample of a simple regular function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquared <- function(x) {\n  x^2\n}\n```\n:::\n\n\nSince this is a short function definition, it can also be written in a single \nline:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquared <- function(x) x^2\n```\n:::\n\n\nAn anonymous function definition is just like a regular function - minus it is\nnot assigned:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction(x) x^2\n```\n:::\n\n\nSince R version 4.1 (May 2021), a compact anonymous function syntax is available,\nwhere a single back slash replaces `function`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\\(x) x^2\n```\n:::\n\n\nLet's use the `squared()` function within `sapply()` to square the first four \ncolumns of the iris dataset. In these examples, we often wrap functions around \n`head()` which prints the first few lines of an object to avoid:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dat[, 1:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age   Weight   Height      SBP\n1 42.49072 88.49907 1.846964 139.2092\n2 46.39626 71.03311 1.879580 132.0072\n3 36.46471 70.61813 1.769191 129.4022\n4 37.82188 80.01291 1.864163 134.0079\n5 54.56728 82.35835 1.727475 129.1432\n6 47.88655 76.11747 1.611482 136.5716\n```\n:::\n\n```{.r .cell-code}\ndat_sq <- sapply(dat[, 1:4], squared)\nhead(dat_sq)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Age   Weight   Height      SBP\n[1,] 1805.461 7832.086 3.411277 19379.20\n[2,] 2152.613 5045.703 3.532823 17425.91\n[3,] 1329.675 4986.921 3.130035 16744.92\n[4,] 1430.494 6402.065 3.475104 17958.12\n[5,] 2977.588 6782.898 2.984169 16677.95\n[6,] 2293.121 5793.870 2.596873 18651.81\n```\n:::\n:::\n\n\nLet's do the same as above, but this time using an anonymous function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_sqtoo <- sapply(dat[, 1:4], function(x) x^2)\nhead(dat_sqtoo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Age   Weight   Height      SBP\n[1,] 1805.461 7832.086 3.411277 19379.20\n[2,] 2152.613 5045.703 3.532823 17425.91\n[3,] 1329.675 4986.921 3.130035 16744.92\n[4,] 1430.494 6402.065 3.475104 17958.12\n[5,] 2977.588 6782.898 2.984169 16677.95\n[6,] 2293.121 5793.870 2.596873 18651.81\n```\n:::\n:::\n\n\nThe entire anonymous function definition is passed to the `FUN` argument.\n\n## Iterating over a sequence instead of an object\n\nWith `lapply()`, `sapply()` and `vapply()` there is a very simple trick that \nmay often come in handy:\n\nInstead of iterating over elements of an object, you can iterate over an integer \nindex of whichever elements you want to access and use it accordingly within \nthe anonymous function.\n\nThis alternative approach is much closer to how we would use an integer \nsequence in a `for` loop.\n\nIt will be clearer through an example, where we get the mean of the first four columns of iris:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# original way: iterate through elements i.e. columns:\nsapply(dat, function(i) mean(i))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in mean.default(i): argument is not numeric or logical: returning NA\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP      Group \n 40.835738  79.042210   1.722052 133.520406         NA \n```\n:::\n\n```{.r .cell-code}\n# alternative way: iterate over integer index of elements:\nsapply(1:4, function(i) mean(dat[, i]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  40.835738  79.042210   1.722052 133.520406\n```\n:::\n\n```{.r .cell-code}\n# equivalent to:\nfor (i in 1:4) {\n  mean(dat[, i])\n}\n```\n:::\n\n\nNotice that in this approach, since you are not passing the object (dat, in \nthe above example) as the input to `lapply()`, it needs to be accessed within \nthe anonymous function.\n",
    "supporting": [
      "LoopFunctions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}