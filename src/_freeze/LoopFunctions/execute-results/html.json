{
  "hash": "ab7be3c3674c94ba3045f3aeede8f721",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk: \n    comment: ''\n    error: true\n---\n\n# Loop Functions {#sec-loopfns}\n\nLoop functions are some of the most widely used R functions. They replace \nlonger expressions created with a `for` loop, for example.  \nThey can result in more compact and readable code.  \n\n| Function   | Description\n|-----------:|----------------------------------------------------------------:|\n| `apply()`  | Apply function over array margins (i.e. over one or more dimensions)\n| `lapply()` | Return a *list* where each element is the result of applying a function to each element of the input\n| `sapply()` | Same as `lapply()`, but returns the simplest possible R object (instead of always returning a list)\n| `vapply()` | Same as `sapply()`, but with a pre-specified return type: this is safer and may also be faster\n| `tapply()` | Apply a function to elements of groups defined by a factor\n| `mapply()` | Multivariate `sapply()`: Apply a function using the 1st elements of the inputs vectors, then using the 2nd, 3rd, etc.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![`*apply()` function family summary (Best to read through this chapter first and then refer back to this figure)](./R_applyfam.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## `apply()` {#apply}\n\n::: callout-tip\n`apply()` applies a function over one or more dimensions of an array of 2 \ndimensions or more (this includes matrices) or a data frame:\n\n`apply(array, MARGIN, FUN)`\n:::\n\n`MARGIN` can be an integer vector or character indicating the dimensions over \nwhich 'FUN' will be applied.\n\nBy convention, rows come first (just like in [indexing](#indexing)), therefore:\n\n- `MARGIN = 1`: apply function on each ***row***\n- `MARGIN = 2`: apply function on each ***column***\n\n\nLet's create an example dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(Age = rnorm(50, 42, 8),\n                  Weight = rnorm(50,80, 10),\n                  Height = rnorm(50, 1.72, .14),\n                  SBP = rnorm(50, 134, 4))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age   Weight   Height      SBP\n1 45.60342 79.54380 1.818788 132.1113\n2 50.31174 84.71499 1.581360 132.3836\n3 44.86804 76.02595 1.757977 128.4993\n4 44.04088 77.20826 1.847194 138.9564\n5 34.69285 77.76647 1.914615 134.3531\n6 37.46224 76.58212 1.760416 133.3626\n```\n:::\n:::\n\n\nLet's calculate the mean value of each column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_column_mean <- apply(dat, MARGIN = 2, FUN = mean) \ndat_column_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP \n 42.140364  81.951596   1.723906 133.833026 \n```\n:::\n:::\n\n\n::: callout-tip\nHint: It is possibly easiest to think of the \"MARGIN\" as the \n***dimension you want to keep***.  \nIn the above case, we want the mean for each variable, i.e. we want to keep \ncolumns and collapse rows.\n:::\n\nPurely as an example to understand what `apply()` does, here is the equivalent\nprocedure using a for-loop. You notice how much more code is needed, and why\n`apply()` and similar functions might be very convenient for many different \ntasks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_column_mean <- numeric(ncol(dat))\nnames(dat_column_mean) <- names(dat)\n\nfor (i in seq(dat)) {\n  dat_column_mean[i] <- mean(dat[, i])\n}\ndat_column_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP \n 42.140364  81.951596   1.723906 133.833026 \n```\n:::\n:::\n\n\nLet's create a different example dataset, where we record weight at multiple\ntimepoints:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- data.frame(ID = seq(8001, 8020),\n                   Weight_week_1 = rnorm(20, 110, 10))\ndat2$Weight_week_3 <- dat2$Weight_week_1 + rnorm(20, -2, 1)\ndat2$Weight_week_5 <- dat2$Weight_week_3 + rnorm(20, -3, 1.1)\ndat2$Weight_week_7 <- dat2$Weight_week_5 + rnorm(20, -1.8, 1.3)\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     ID Weight_week_1 Weight_week_3 Weight_week_5 Weight_week_7\n1  8001     132.08939     130.58336     128.49015     126.15048\n2  8002     103.82686     102.78273      99.70680      98.42220\n3  8003     119.13845     118.85812     116.46069     115.81320\n4  8004     122.08875     118.72534     114.64687     113.19843\n5  8005     105.93560     103.81601     102.33430     100.84995\n6  8006     114.16563     111.58564     109.76321     107.72406\n7  8007     100.77728      99.49872      96.98454      96.51662\n8  8008     114.17205     112.11275     109.27489     108.80971\n9  8009      99.70150      98.97243      95.90463      92.74555\n10 8010     105.73088     102.70548     100.10734      98.23887\n11 8011      91.12492      87.16789      84.05768      83.09267\n12 8012     128.10388     126.47138     126.06478     126.14184\n13 8013     106.05366     104.32790     102.98725     100.47984\n14 8014     102.73514     100.39599      97.97730      97.26584\n15 8015      98.76227      96.71468      93.55724      90.92724\n16 8016     104.71856     101.77267     100.23437      99.37216\n17 8017     107.99487     105.52835     103.31889     102.05802\n18 8018     131.06226     130.95377     127.99273     128.71585\n19 8019      98.44492      94.62092      93.11937      92.27063\n20 8020     118.54287     117.78231     114.80990     114.14027\n```\n:::\n:::\n\n\nLet's get the mean weight per week:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(dat2[, -1], 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWeight_week_1 Weight_week_3 Weight_week_5 Weight_week_7 \n     110.2585      108.2688      105.8896      104.6467 \n```\n:::\n:::\n\n\nLet's get the mean weight per individual across all weeks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(dat2[, -1], 1, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 129.32834 101.18465 117.56762 117.16485 103.23396 110.80963  98.44429\n [8] 111.09235  96.83103 101.69564  86.36079 126.69547 103.46216  99.59357\n[15]  94.99035 101.52444 104.72503 129.68115  94.61396 116.31884\n```\n:::\n:::\n\n\n::: callout-caution\n`apply()` converts 2-dimensional objects to matrices before applying the\nfunction. Therefore, if applied on a data.frame with mixed data types, it will\nbe coerced to a character matrix.\n\nThis is explained in the `apply()` documentation under \"Details\":\n\n*\"If X is not an array but an object of a class with a non-null dim value (such as a data frame), apply attempts to coerce it to an array via as.matrix if it is two-dimensional (e.g., a data frame) or via as.array.\"*\n:::\n\nBecause of the above, see what happens when you use apply on the `iris` data.frame which contains 4 numeric variables and one factor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napply(iris, 2, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n \"character\"  \"character\"  \"character\"  \"character\"  \"character\" \n```\n:::\n:::\n\n\n## `lapply()` {#lapply}\n\n::: callout-tip\n`lapply()` applies a **function** on **each element of its input** and returns \na **list** of the outputs.  \n:::\n\nNote: The 'elements' of a data frame are its columns (remember, a data frame is \na list with equal-length elements). The 'elements' of a matrix are each cell \none by one, by column. Therefore, unlike `apply()`, `lapply()` has a very \ndifferent effect on a data frame and a matrix. `lapply()` is commonly used to \niterate over the columns of a data frame.\n\n::: callout-tip\n`lapply()` is the only function of the `*apply()` family that always returns a \nlist.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_median <- lapply(dat, median)\ndat_median\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Age\n[1] 42.3176\n\n$Weight\n[1] 80.28772\n\n$Height\n[1] 1.748442\n\n$SBP\n[1] 133.4554\n```\n:::\n:::\n\n\nTo understand what `lapply()` does, here is the equivalent for-loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_median <- vector(\"list\", length = 4)\nnames(dat_median) <- colnames(dat)\nfor (i in 1:4) {\n  dat_median[[i]] <- median(dat[, i])\n}\ndat_median\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Age\n[1] 42.3176\n\n$Weight\n[1] 80.28772\n\n$Height\n[1] 1.748442\n\n$SBP\n[1] 133.4554\n```\n:::\n:::\n\n\n## `sapply()` {#sapply}\n\n`sapply()` is an alias for `lapply()`, followed by a call to `simplify2array()`.  \n(Check the source code for `sapply()` by typing `sapply` at the console).  \n\n\n::: callout-note\nUnlike `lapply()`, the output of `sapply()` is **variable**: \nit is the simplest R  object that can hold the data type(s) resulting from the \noperations, i.e. a vector, matrix, data frame, or list.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_median <- sapply(dat, median)\ndat_median\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP \n 42.317601  80.287719   1.748442 133.455438 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_summary <- data.frame(Mean = sapply(dat, mean),\n                           SD = sapply(dat, sd))\ndat_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Mean        SD\nAge     42.140364 8.4931821\nWeight  81.951596 9.2576175\nHeight   1.723906 0.1452857\nSBP    133.833026 4.0454389\n```\n:::\n:::\n\n\n### Example: Get index of numeric variables\n\nLet's use `sapply()` to get an index of numeric columns in dat2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ID Weight_week_1 Weight_week_3 Weight_week_5 Weight_week_7\n1 8001      132.0894      130.5834      128.4901      126.1505\n2 8002      103.8269      102.7827       99.7068       98.4222\n3 8003      119.1385      118.8581      116.4607      115.8132\n4 8004      122.0888      118.7253      114.6469      113.1984\n5 8005      105.9356      103.8160      102.3343      100.8499\n6 8006      114.1656      111.5856      109.7632      107.7241\n```\n:::\n:::\n\n\nlogical index of numeric columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumidl <- sapply(dat2, is.numeric)\n```\n:::\n\n\ninteger index of numeric columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumidi <- which(sapply(dat2, is.numeric))\n```\n:::\n\n\n## `vapply()` {#vapply}\n\nMuch less commonly used (possibly *underused*) than `lapply()` or `sapply()`, \n`vapply()` allows you to specify what the expected output looks like - for \nexample a numeric vector of length 2, a character vector of length 1.\n\nThis can have two advantages:\n\n- It is safer against errors\n- It will sometimes be a little faster\n\nYou add the argument `FUN.VALUE` which must be of the correct **type** and \n**length** of the expected result ***of each iteration***.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(dat, median, FUN.VALUE = .1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP \n 42.317601  80.287719   1.748442 133.455438 \n```\n:::\n:::\n\n\nHere, each iteration returns the median of each column, i.e. a numeric vector \nof length 1.\n\nTherefore `FUN.VALUE` can be any numeric scalar.\n\nFor example, if we instead returned the range of each column, `FUN.VALUE` \nshould be a numeric vector of length 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(dat, range, FUN.VALUE = rep(.1, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Age    Weight   Height      SBP\n[1,] 15.01389  57.14368 1.426149 125.2551\n[2,] 60.88502 103.60867 2.049046 144.7807\n```\n:::\n:::\n\n\nIf `FUN.VALUE` does not match the returned value, we get an informative error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(dat, range, FUN.VALUE = .1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in vapply(dat, range, FUN.VALUE = 0.1): values must be length 1,\n but FUN(X[[1]]) result is length 2\n```\n:::\n:::\n\n\n## `tapply()` {#tapply}\n\n`tapply()` is one way (of many) to apply a function on **subgroups of data** \nas defined by one or more factors.  \nIn the following example, we calculate the mean Sepal.Length by species on the \niris dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$Group <- factor(sample(c(\"A\", \"B\", \"C\"), size = 50, replace = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_Age_by_Group <- tapply(dat[[\"Age\"]], dat[\"Group\"], mean)\nmean_Age_by_Group\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGroup\n       A        B        C \n42.12877 41.11700 43.11513 \n```\n:::\n:::\n\n\nThe for-loop equivalent of the above is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- levels(dat$Group)\nmean_Age_by_Group <- vector(\"numeric\", length = length(groups))\nnames(mean_Age_by_Group) <- groups\n\nfor (i in seq(groups)) {\n  mean_Age_by_Group[i] <- \n    mean(dat$Age[dat$Group == groups[i]])\n}\nmean_Age_by_Group\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A        B        C \n42.12877 41.11700 43.11513 \n```\n:::\n:::\n\n\n## `mapply()` {#mapply}\n\nThe functions we have looked at so far work well when you iterating over \nelements of a single object.\n\n`mapply()` allows you to execute a function that accepts two or more inputs, \nsay `fn(x, z)` using the i-th element of each input, and will return:  \n`fn(x[1], z[1])`, `fn(x[2], z[2])`, ..., `fn(x[n], z[n])`\n\nLet's create a simple function that accepts two numeric arguments, and two \nvectors length 5 each:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraise <- function(x, power) x^power\nx <- 2:6\np <- 6:2\n```\n:::\n\n\nUse mapply to raise each `x` to the corresponding `p`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- mapply(raise, x, p)\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  64 243 256 125  36\n```\n:::\n:::\n\n\nThe above is equivalent to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- vector(\"numeric\", length = 5)\nfor (i in seq(5)) {\n  out[i] <- raise(x[i], p[i])\n}\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  64 243 256 125  36\n```\n:::\n:::\n\n\n## `*apply()`ing on matrices vs. data frames\n\nTo consolidate some of what was learned above, let's focus on the difference \nbetween working on a matrix vs. a data frame.  \nFirst, let's create a matrix and a data frame with the same data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\namat <- matrix(21:70, nrow = 10)\ncolnames(amat) <- paste0(\"Feature_\", 1:ncol(amat))\namat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Feature_1 Feature_2 Feature_3 Feature_4 Feature_5\n [1,]        21        31        41        51        61\n [2,]        22        32        42        52        62\n [3,]        23        33        43        53        63\n [4,]        24        34        44        54        64\n [5,]        25        35        45        55        65\n [6,]        26        36        46        56        66\n [7,]        27        37        47        57        67\n [8,]        28        38        48        58        68\n [9,]        29        39        49        59        69\n[10,]        30        40        50        60        70\n```\n:::\n\n```{.r .cell-code}\nadf <- as.data.frame(amat)\nadf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Feature_1 Feature_2 Feature_3 Feature_4 Feature_5\n1         21        31        41        51        61\n2         22        32        42        52        62\n3         23        33        43        53        63\n4         24        34        44        54        64\n5         25        35        45        55        65\n6         26        36        46        56        66\n7         27        37        47        57        67\n8         28        38        48        58        68\n9         29        39        49        59        69\n10        30        40        50        60        70\n```\n:::\n:::\n\n\nWe've seen that with `apply()` we specify the dimension to operate on and it \nworks the same way on both matrices and data frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(amat, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFeature_1 Feature_2 Feature_3 Feature_4 Feature_5 \n     25.5      35.5      45.5      55.5      65.5 \n```\n:::\n\n```{.r .cell-code}\napply(adf, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFeature_1 Feature_2 Feature_3 Feature_4 Feature_5 \n     25.5      35.5      45.5      55.5      65.5 \n```\n:::\n:::\n\n\nHowever, `sapply()` (and `lapply()`, `vapply()`) acts on ***each element*** of \nthe object, therefore it is not meaningful to pass a matrix to it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(amat, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45\n[26] 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70\n```\n:::\n:::\n\n\nThe above returns the mean of each element, i.e. the element itself, which is \nmeaningless.\n\nSince a data frame is a list, and its columns are its elements, it works great \nfor column operations on data frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(adf, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFeature_1 Feature_2 Feature_3 Feature_4 Feature_5 \n     25.5      35.5      45.5      55.5      65.5 \n```\n:::\n:::\n\n\nIf you want to use `sapply()` on a matrix, you could iterate over an integer \nsequence as shown in the previous section:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(1:ncol(amat), function(i) mean(amat[, i]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25.5 35.5 45.5 55.5 65.5\n```\n:::\n:::\n\n\nThis is shown to help emphasize the differences between the function and the \ndata structures. In practice, you would use `apply()` on a matrix.\n\n## Anonymous functions {#anonfns}\n\nAnonymous functions are just like regular functions but they are not assigned \nto an object - i.e. they are not \"named\".  \nThey are usually passed as arguments to other functions to be used once, hence \nno need to assign them.\n\nAnonymous functions are often used with the apply family of functions.  \n\nExample of a simple regular function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquared <- function(x) {\n  x^2\n}\n```\n:::\n\n\nSince this is a short function definition, it can also be written in a single \nline:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquared <- function(x) x^2\n```\n:::\n\n\nAn anonymous function definition is just like a regular function - minus it is\nnot assigned:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction(x) x^2\n```\n:::\n\n\nSince R version 4.1 (May 2021), a compact anonymous function syntax is available,\nwhere a single back slash replaces `function`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\\(x) x^2\n```\n:::\n\n\nLet's use the `squared()` function within `sapply()` to square the first four \ncolumns of the iris dataset. In these examples, we often wrap functions around \n`head()` which prints the first few lines of an object to avoid:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dat[, 1:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age   Weight   Height      SBP\n1 45.60342 79.54380 1.818788 132.1113\n2 50.31174 84.71499 1.581360 132.3836\n3 44.86804 76.02595 1.757977 128.4993\n4 44.04088 77.20826 1.847194 138.9564\n5 34.69285 77.76647 1.914615 134.3531\n6 37.46224 76.58212 1.760416 133.3626\n```\n:::\n\n```{.r .cell-code}\ndat_sq <- sapply(dat[, 1:4], squared)\nhead(dat_sq)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Age   Weight   Height      SBP\n[1,] 2079.672 6327.215 3.307990 17453.40\n[2,] 2531.272 7176.630 2.500700 17525.41\n[3,] 2013.141 5779.946 3.090482 16512.08\n[4,] 1939.599 5961.116 3.412125 19308.89\n[5,] 1203.594 6047.623 3.665751 18050.74\n[6,] 1403.419 5864.821 3.099063 17785.57\n```\n:::\n:::\n\n\nLet's do the same as above, but this time using an anonymous function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_sqtoo <- sapply(dat[, 1:4], function(x) x^2)\nhead(dat_sqtoo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Age   Weight   Height      SBP\n[1,] 2079.672 6327.215 3.307990 17453.40\n[2,] 2531.272 7176.630 2.500700 17525.41\n[3,] 2013.141 5779.946 3.090482 16512.08\n[4,] 1939.599 5961.116 3.412125 19308.89\n[5,] 1203.594 6047.623 3.665751 18050.74\n[6,] 1403.419 5864.821 3.099063 17785.57\n```\n:::\n:::\n\n\nThe entire anonymous function definition is passed to the `FUN` argument.\n\n## Iterating over a sequence instead of an object\n\nWith `lapply()`, `sapply()` and `vapply()` there is a very simple trick that \nmay often come in handy:\n\nInstead of iterating over elements of an object, you can iterate over an integer \nindex of whichever elements you want to access and use it accordingly within \nthe anonymous function.\n\nThis alternative approach is much closer to how we would use an integer \nsequence in a `for` loop.\n\nIt will be clearer through an example, where we get the mean of the first four columns of iris:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# original way: iterate through elements i.e. columns:\nsapply(dat, function(i) mean(i))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in mean.default(i): argument is not numeric or logical: returning NA\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n       Age     Weight     Height        SBP      Group \n 42.140364  81.951596   1.723906 133.833026         NA \n```\n:::\n\n```{.r .cell-code}\n# alternative way: iterate over integer index of elements:\nsapply(1:4, function(i) mean(dat[, i]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  42.140364  81.951596   1.723906 133.833026\n```\n:::\n\n```{.r .cell-code}\n# equivalent to:\nfor (i in 1:4) {\n  mean(dat[, i])\n}\n```\n:::\n\n\nNotice that in this approach, since you are not passing the object (dat, in \nthe above example) as the input to `lapply()`, it needs to be accessed within \nthe anonymous function.\n",
    "supporting": [
      "LoopFunctions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}