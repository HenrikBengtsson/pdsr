{
  "hash": "5229a1401122331bfffaf523f33bd91e",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk:\n    comment: \"\"\n    cache: true\n---\n\n# Data Types & Vectors {#sec-datatypes}\n\n## Base types\n\nThe simplest and most fundamental object in R is the vector: a one-dimensional \ncollection of elements of the same data type, e.g. numbers, characters, etc.\n(known as an \"atomic\" vector).\n<br><br>\nFor example, a numeric vector may consist of elements `12, 14, 20`, and a \ncharacter vector may consist of elements `\"x\", \"y\", \"apple\", \"banana\"`.\n<br><br>\nVectors can exist as stand-alone objects, or they can exist within other data \nstructures, e.g. data.frames, lists, etc.\n<br><br>\nThis chapter covers different atomic vectors, and the next covers data \nstructures (@sec-datastructures).\n<br><br>\nR includes a number of builtin data types. These are defined by R - users cannot define their own data types.\n<br><br>\nUsers can, however, define their own classes (@sec-classes).\n<br><br>\nThe main/most common data types in R are:\n\n- **numeric**, including **integer** and [**double**](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)\n- **character**\n- **logical** (i.e. TRUE, FALSE, or NA, a.k.a. [Boolean](https://en.wikipedia.org/wiki/Boolean_data_type))\n\nOther data types include environments and closures i.e. functions \n(@sec-functions).\n\n## Assignment\n\nUse `<-` for all assignments:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-1_3745c62b62a60b357c4a3b3921435ee4'}\n\n```{.r .cell-code}\nx <- 3\n# You can add comments within code blocks using the usual \"#\" prefix\n```\n:::\n\n\n::: callout-note\nIn [RStudio](https://rstudio.com/), the keyboard shortcut for the assignment \noperator `<-` is `Option -` (macOS) or `Alt -` (Windows).\n:::\n\nTyping the name of an object, e.g.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-2_e26756420a52a90ca57261e57813a135'}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nis equivalent to printing it, e.g.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-3_140f40e01a86a40285fc77bd6aa2b976'}\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nYou can also place any assignment in parentheses and this will perform the \nassignment and print the object:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-4_d01177977e783843917ff2ba0675b123'}\n\n```{.r .cell-code}\n(x <- 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n::: callout-note\nYou can use either `<-` or `=` for assignment. \nHowever, many R syntax guides advise to use `<-` for assignment and `=` for passing\narguments to functions.\n:::\n\nYou can assign the same value to multiple objects - this can be useful when \ninitializing variables.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-5_5eb3ec508ee0d4106e44c4331e3a7cd9'}\n\n```{.r .cell-code}\nx <- z <- init <- 0\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ninit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nExcitingly, R allows assignment in the opposite direction as well:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-6_aca3aee8cf35eaa8cd8691692820e64c'}\n\n```{.r .cell-code}\n10 -> x\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\nWe shall see later that the `->` assignment can be convenient at the end of a \n[pipe](https://class.lambdamd.org/progdatscir/functions.html#the-pipe-operator).\n\nYou can even do the following, which is fun, if not particularly useful:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-7_bfe15f04345f52aefdf7454b3b55387f'}\n\n```{.r .cell-code}\nx <- 7 -> z\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n::: callout-note\nIt's good practice to use clear and descriptive names for all objects you \ncreate.\n\nFor multi-word names, snake case is a good option:\n\n`admission_date, age_at_onset, etc.`\n:::\n\n::: callout-caution\nAvoid naming new objects using names of built-in commands.\nFor example, avoid assigning your data to an object named `data`, since that\ncould conflict with the built-in function `data()`.\n::: \n\n## Create vectors with `c()` \n\nUse `c()` to **c**ombine multiple values into a vector:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-8_5200de6125594547e9e75c212bcbfff9'}\n\n```{.r .cell-code}\nx <- c(-12, 3.5, 104)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -12.0   3.5 104.0\n```\n\n\n:::\n:::\n\n\n## Get the type of a vector using `typeof()`\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-9_14eac68ce3c2a2249d0a1f1734be7b31'}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n## Common vector types\n\nLet's create some example vectors of the most common data types:\n\n### Integer {#integervectors}\n\nNumeric vector default to double;\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-10_37750c86ec8b86ca9698a1a198cfc66c'}\n\n```{.r .cell-code}\nv <- c(12, 14, 23)\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 14 23\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\nTo create an integer vector, you can follow numbers by an \"L\";\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-11_a5e85e671d22513f5fdd846698ae51b2'}\n\n```{.r .cell-code}\nvi <- c(12L, 14L, 23L)\nvi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 14 23\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(vi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\nAlternatively you can coerce a double to integer using `as.integer()`;\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-12_f43b9f3829e0ab200d7d2af51d421fa6'}\n\n```{.r .cell-code}\nvi <- as.integer(c(12, 14, 23))\nvi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 14 23\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(vi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n### Double {#doublevectors}\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-13_9a89fc5c504ab417f0fb766a5f0551ac'}\n\n```{.r .cell-code}\nvd <- c(1.3, 2.8, 3.6)\nvd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.3 2.8 3.6\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(vd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n### Character {#charactervectors}\n\nA character vector consists of one or more elements, each of which consists of \none or more actual characters, i.e. it is **not** a vector of single \ncharacters. (The length of a character vector is the number of individual \nelements, and is not related to the number of characters in each element)\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-14_abbcc3b83206b16fc0bb13870e4c8d5b'}\n\n```{.r .cell-code}\nvc <- c(\"a\", \"d\", \"s\")\nvc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"d\" \"s\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(vc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n### Logical {#logicalvectors}\n\nLogical vectors typically consist of `TRUE` and `FALSE` values, but may also consist of `NA` (missing value). One important use of logical vectors is in indexing (@sec-indexing).\n\nWhen you are writing code, use `TRUE` and `FALSE`.  \nDuring interactive work, you can abbreviate to `T` and `F`.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-15_3c0ea77856acb883c6b415c64a0c99a1'}\n\n```{.r .cell-code}\nvl <- c(TRUE, FALSE, FALSE)\nvl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(vl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n## Initialize vectors {#initvectors}\n\nInitializing a vector or other data structure is the process by which you create\nan object of a certain size with some initial values, e.g. all zeros or all \n[`NA`](#na), in order to replace with other values later.\n\nThis is usually computationally more efficient than starting with a small object\nand appending to it multiple times.\n<br><br>\nYou can create / initialize vectors of specific type with the `vector` command \nand specifying a `mode` or directly by calling the relevant function:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-16_35e6b9d86103e642f6c7ccb7c7bbae8a'}\n\n```{.r .cell-code}\n(xl <- vector(mode = \"logical\", length = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n(xd <- vector(mode = \"double\", length = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\n(xn <- vector(mode = \"numeric\", length = 10)) # same as \"double\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\n(xi <- vector(mode = \"integer\", length = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\n(xc <- vector(mode = \"character\", length = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\n```\n\n\n:::\n:::\n\n\nThese are aliases of the `vector` command above (print their source code to see \nfor yourself)\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-17_13cd0b4a67dcfb8d43021dadcb5eeeda'}\n\n```{.r .cell-code}\n(xl <- logical(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n(xd <- double(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\n(xn <- numeric(10)) # same as double\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\n(xi <- integer(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\n(xc <- character(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\n```\n\n\n:::\n:::\n\n\n## Explicit coercion\n\nWe can explicitly convert vector of one type to a different type using `as.*` \nfunctions:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-18_9ffb6b3b7e3e624270735ebfd976ea79'}\n\n```{.r .cell-code}\nx <- c(1.2, 2.3, 3.4)\nas.logical(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.double(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 2.3 3.4\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 2.3 3.4\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nas.character(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1.2\" \"2.3\" \"3.4\"\n```\n\n\n:::\n:::\n\n\nLogical vectors are converted to 1s and 0s as expected, where TRUE becomes 1 and FALSE becomes 0, e.g.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-19_a2f64893b76455259de7b4a054d6cba6'}\n\n```{.r .cell-code}\nx <- c(TRUE, TRUE, FALSE)\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 0\n```\n\n\n:::\n:::\n\n\nNote that when converting from numeric to logical, \n**anything other than zero is TRUE**:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-20_d0c8b5785b348dc20e11186904acfa6f'}\n\n```{.r .cell-code}\nx <- seq(-2, 2, .5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\nNot all conversions are possible.  \nThere is no meaningful/consistent way to convert a character vector to numeric.  \nThe following outputs NA values and prints a helpful warning message.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-21_7701a4be752a15a5c18a6bf45a38a851'}\n\n```{.r .cell-code}\nx <- c(\"mango\", \"banana\", \"tangerine\")\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA NA\n```\n\n\n:::\n:::\n\n\n## Implicit coercion\n\nRemember, the language generally tries to make life easier. Sometimes this \nmeans it will automatically coerce one class to another to allow requested \noperations.\n<br><br>\nFor example, you can get the sum of a logical vector.  \nIt will automatically be converted to numeric as we saw earlier.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-22_87f7b3708345f7f3adfc18ac1cea150c'}\n\n```{.r .cell-code}\nx <- c(TRUE, TRUE, FALSE)\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\nOn the other hand, you cannot sum a [factor](#factors), for example.  \nYou get an error with an explanation:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-23_ea876e628646131971f3ee63ae78127b'}\n\n```{.r .cell-code}\nx <- factor(c(\"mango\", \"banana\", \"mango\"))\nsum(x)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in Summary.factor(structure(c(2L, 1L, 2L), levels = c(\"banana\", : 'sum' not meaningful for factors\n```\n\n\n:::\n:::\n\n\n::: callout-caution\nMany errors in R occur because a variable is, or gets coerced to, the wrong \ntype or class (see @sec-datastructures) by accident.\nThat's why it is essential to be able to:\n\n- check the type of a variable using `typeof()` or `class()`\n- convert (coerce) between types or classes using `as.*` functions\n::: \n\n## `NA`: Missing value {#na}\n\nMissing values in any data type - logical, integer, double, or character - are coded using `NA`.  \nTo check for the presence of `NA` values, use `is.na()`:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-24_ef302b2b2a4f6755c614de4adf17ba95'}\n\n```{.r .cell-code}\nx <- c(1.2, 5.3, 4.8, NA, 9.6)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 5.3 4.8  NA 9.6\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-25_bc5ffd21a8861df858ec95fa736990bb'}\n\n```{.r .cell-code}\nx <- c(\"mango\", \"banana\", NA, \"sugar\", \"ackee\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"mango\"  \"banana\" NA       \"sugar\"  \"ackee\" \n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-26_cb3445ca73832c98c5e0010897bdffee'}\n\n```{.r .cell-code}\nx <- c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, NA)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE  TRUE FALSE FALSE    NA\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n`is.na()` works similarly on matrices:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-27_2790caf2180adbff12ade0902556acc1'}\n\n```{.r .cell-code}\nx <- matrix(1:20, 5)\nx[4, 3] <- NA\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1]  [,2]  [,3]  [,4]\n[1,] FALSE FALSE FALSE FALSE\n[2,] FALSE FALSE FALSE FALSE\n[3,] FALSE FALSE FALSE FALSE\n[4,] FALSE FALSE  TRUE FALSE\n[5,] FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n::: callout-note\nNote that `is.na()` returns a response for each element \n(i.e. is [vectorized](#vectorization)) in contrast to `is.numeric()`, \n`is.logical()`, etc. The latter are checking the type of \nan object, while the former is checking individual elements. \n::: \n\n`anyNA()` is a very useful function to check if there is one ore more missing values in an object, e.g.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-28_a5f9f2b746e58497a5e944332f906087'}\n\n```{.r .cell-code}\nanyNA(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n::: callout-note\nOperation on `NA` values results in `NA`.\n:::\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-29_ceca88911aec9fc5d6f98aa0e986c695'}\n\n```{.r .cell-code}\nx <- c(1.2, 5.3, 4.8, NA, 9.6)\nx*2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2.4 10.6  9.6   NA 19.2\n```\n\n\n:::\n:::\n\n\nMultiple functions that accept as input an object with multiple values (a \nvector, a matrix, a data.frame, etc.) will return `NA` if *any* element is `NA`:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-30_bb7e4e29dbb69f092f3fa703acf9b798'}\n\n```{.r .cell-code}\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA\n```\n\n\n:::\n:::\n\n\nFirst, make sure `NA` values represent legitimate missing data and not some \nerror. Then, decide how you want to handle it.\n\nIn all of the above commands you can pass `na.rm = TRUE` to ignore `NA` values:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-31_8d4880ac7e312bbbb12456d38bd2b2aa'}\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.225\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.05\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.441293\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9.6\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 9.6\n```\n\n\n:::\n:::\n\n\nMore generally, you can use `na.exclude()` to exclude NA values from R objects. \nThis can be very useful for function that do not include a `na.rm` or similar \nargument to handle `NA` values.\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-32_883b7d218c3b20f2b75b19fa63acf77d'}\n\n```{.r .cell-code}\nx <- c(1, 2, NA, 4)\nna.exclude(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 4\nattr(,\"na.action\")\n[1] 3\nattr(,\"class\")\n[1] \"exclude\"\n```\n\n\n:::\n:::\n\n\nOn a data.frame, `na.exclude()` excludes rows with any `NA`s:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-33_43f37fee9cf11bff8739055f9c94ffb8'}\n\n```{.r .cell-code}\ndf <- data.frame(a = c(1, 2, NA, 4),\n                 b = c(11, NA, 13, 14))\nna.exclude(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a  b\n1 1 11\n4 4 14\n```\n\n\n:::\n:::\n\n\n@sec-missingdata describes some approaches to handling missing data in the context of statistics or machine learning.\n\n## `NA` types {#natypes}\n\nIn the above examples, `NA` was used in vectors of different types. In reality, `NA`\nis a logical constant of length 1 that gets coerced to the type of the vector it is\nplaced in. To specify `NA` of a specific type, use the appropriate `NA_*` constant:\n\n- `NA_integer_`\n- `NA_real_`\n- `NA_complex_`\n- `NA_character_`\n\nSee `?NA` for more details. These can be useful when you want to initialize a \nvector/matrix/array of a specific type with `NA` values (for example, see (#initmatrix)).\n\n## `NaN`: Not a number\n\n`NaN` is a special case of `NA` and can be the result of undefined mathematical \noperations:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-34_c4fa54eeb9a9bfdfdb653225840a6d01'}\n\n```{.r .cell-code}\na <- log(-4)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in log(-4): NaNs produced\n```\n\n\n:::\n:::\n\n\nNote that `class()` returns \"numeric\":\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-35_0d64f2d0f0d4c9c7ba01d891b3902cd0'}\n\n```{.r .cell-code}\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\nTo test for `NaN`s, use:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-36_1f1e4ff0a7234fcf9e43cd91387eabbb'}\n\n```{.r .cell-code}\nis.nan(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n`NaN`s are also `NA`:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-37_7b90f3a4bb650366a9bfc5022ff7db73'}\n\n```{.r .cell-code}\nis.na(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nBut the opposite is not true:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-38_8b6e98e7eec843d3e1369b79e1d4fac8'}\n\n```{.r .cell-code}\nis.nan(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n::: callout-note\n`NaN` can be considered a subtype of `NA`, \nas such: `is.na(NaN)` is `TRUE`, \nbut `is.nan(NA)` is `FALSE`.\n:::\n\n## `NULL`: The empty object\n\nThe `NULL` object represents an empty object.\n\n::: callout-note\n`NULL` means empty, ***not missing***, and is therefore entirely different from `NA`.\n:::\n\n`NULL` shows up for example when initializing a list:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-39_f6f521db82182e5245e94071e1550d4c'}\n\n```{.r .cell-code}\na <- vector(\"list\", 4)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n\n[[4]]\nNULL\n```\n\n\n:::\n:::\n\n\nand it can be replaced normally:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-40_855d1feaa5e363a38cad23bd62cc7e67'}\n\n```{.r .cell-code}\na[[1]] <- 3\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n\n[[4]]\nNULL\n```\n\n\n:::\n:::\n\n\n### Replacing with NULL\n\nYou cannot replace one or more elements of a vector/matrix/array with `NULL` \nbecause `NULL` has length 0 and replacement requires object of equal length:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-41_8a2fe554514b36caa4995314d2765bba'}\n\n```{.r .cell-code}\na <- 11:15\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 12 13 14 15\n```\n\n\n:::\n\n```{.r .cell-code}\na[1] <- NULL\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in a[1] <- NULL: replacement has length zero\n```\n\n\n:::\n:::\n\n\nHowever, in lists, and therefore also data frames (see #dataframestruc), replacing an \nelement with `NULL` ***removes that element***:\n\n\n::: {.cell hash='DataTypes_cache/html/unnamed-chunk-42_fc4ec685d8ab851fdd5f3497853f6825'}\n\n```{.r .cell-code}\nal <- list(alpha = 11:15,\n           beta = rnorm(10),\n           gamma = c(\"mango\", \"banana\", \"tangerine\"))\nal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$alpha\n[1] 11 12 13 14 15\n\n$beta\n [1]  0.1322462  0.2134345 -0.2389028  0.6420716 -0.5014491  0.7055341\n [7]  0.5527541  2.7612183 -0.7295783 -0.3204961\n\n$gamma\n[1] \"mango\"     \"banana\"    \"tangerine\"\n```\n\n\n:::\n\n```{.r .cell-code}\nal[[2]] <- NULL\nal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$alpha\n[1] 11 12 13 14 15\n\n$gamma\n[1] \"mango\"     \"banana\"    \"tangerine\"\n```\n\n\n:::\n:::\n\n\nFinally, `NULL` is often used as the default value in a function's argument. \nThe function definition must then determine what the default behavior/value \nshould be.\n\n## Initialize - coerce - test vectors\n\nThe following summary table lists the functions to *initialize*, \n*coerce* (=convert), and *test* the main different vector types:\n<br><br>\n\n| **Initialize** | **Coerce**        | **Test**          |\n|---------------:|------------------:|------------------:|\n| `logical(n)`   | `as.logical(x)`   | `is.logical(x)`   |\n| `integer(n)`   | `as.integer(x)`   | `is.integer(x)`   |\n| `double(n)`    | `as.double(x)`    | `is.double(x)`    |\n| `numeric(n)`   | `as.numeric(x)`   | `is.numeric(x)`   |\n| `character(n)` | `as.character(x)` | `is.character(x)` |\n\n::: callout-note\nNote that `numeric` and `double` functions on lines 3 and 4 above are equivalent. \n(Try printing `numeric` and `double` in the console and compare.)\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}