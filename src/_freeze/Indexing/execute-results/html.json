{
  "hash": "625642e291c9356f1714a4f67482be29",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk:\n    comment: \"\"\n---\n\n# Indexing {#sec-indexing}\n\nAn index is used to pick elements of a data structure (i.e. a vector, matrix, \narray, list, data frame, etc.). You can select (or exclude) one or multiple \nelements at a time.\n<br><br>\nThere are three types of index vectors you can use in R to identify elements of\nan object:\n\n- **Integer vector** defining index of elements to include (or exclude)\n- **Logical vector** specifying whether to include or not each element\n- **Character vector** identifying elements, rows, or columns by name\n\nInteger indexing in R is 1-based, meaning the first item of a vector is in \nposition 1. In contrast, many programming languages use \n[0-based indexing](https://en.wikipedia.org/wiki/Zero-based_numbering#Computer_programming) \nwhere the first element is in the 0th position, the second in the 1st, and the \nnth in the n-1 position.\n<br><br>\nTo understand indexing, make sure you are very comfortable with the core\n[R data structures](#structures): vectors, matrices, arrays, lists, and\ndata.frames.\n<br><br>\n***What is indexing used for?***\n\nIndexing can be used to **get** values from an object or to **set** \nvalues in an object.\n<br><br>\nThe main indexing operator in R is the square bracket `[]`.\n\nLists use double square brackets `[[]]`.\n\n## Vectors {#indexvectors}\n\nStart with a simple vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 15:24\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 15 16 17 18 19 20 21 22 23 24\n```\n\n\n:::\n:::\n\n\n### Integer Index\n\nGet the 5th element of a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19\n```\n\n\n:::\n:::\n\n\nGet elements 6 through 9 of the same vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[6:9]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 21 22 23\n```\n\n\n:::\n:::\n\n\nAn integer index can be used to reverse order of elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[5:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19 18 17\n```\n\n\n:::\n:::\n\n\nNote that an integer index can be used to repeat elements. This is often\ndone by accident, when someone passes the wrong vector as an index, so beware.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(1, 1, 1, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15 15 15 18\n```\n\n\n:::\n:::\n\n\n### Logical Index\n\nLogical indexes are usually created as the output of a logical operation, \ni.e. an elementwise comparison.\n<br><br>\nSelect elements with value greater than 19:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidl <- x > 19\n```\n:::\n\n\nThe above comparison is vectorized (@sec-vectorization), meaning that the\ncomparison is performed elementwise and the result is a logical vector of the\nsame length as the original vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\nYou can pass the logical vector as an index to the original vector to get the\nelements that correspond to TRUE in the logical vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[idl]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 21 22 23 24\n```\n\n\n:::\n:::\n\n\nLogical vectors can be created directly in the brackets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 19]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 21 22 23 24\n```\n\n\n:::\n:::\n\n\n### Extract vs. Replace i.e. Get vs. Set\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(24, 32, 41, 37, 999, 999, 999)\n```\n:::\n\n\nIndexing allows you to access specific elements, for example to perform \ncalculations on them.\n\nGet the mean of elements 1 through 4:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x[1:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 33.5\n```\n\n\n:::\n:::\n\n\nYou can combine indexing with assignment to **replace** elements of an object.\n\nReplace values in elements 1:4 with their log:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1:4] <- log(x[1:4])\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   3.178054   3.465736   3.713572   3.610918 999.000000 999.000000 999.000000\n```\n\n\n:::\n:::\n\n\nReplace elements that are equal to 999 with NA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x == 999] <- NA\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.178054 3.465736 3.713572 3.610918       NA       NA       NA\n```\n\n\n:::\n:::\n\n\n## Matrices {#indexmatrices}\n\nReminder:\n\n- A matrix is a 2D vector and contains elements of the same type (numeric, \ninteger, character, etc.).\n- A data frame is a 2D list and each column can contain a different data type.\n\nTo index a 2D structure, whether a matrix or data frame, we use the form:\n `[row, column]`.\n\nThe following indexing operations are therefore the same whether applied on a \nmatrix or a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(21:60, 10)\ncolnames(mat) <- paste0(\"Feature_\", seq(ncol(mat)))\nrownames(mat) <- paste0(\"Row_\", seq(nrow(mat)))\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Feature_1 Feature_2 Feature_3 Feature_4\nRow_1         21        31        41        51\nRow_2         22        32        42        52\nRow_3         23        33        43        53\nRow_4         24        34        44        54\nRow_5         25        35        45        55\nRow_6         26        36        46        56\nRow_7         27        37        47        57\nRow_8         28        38        48        58\nRow_9         29        39        49        59\nRow_10        30        40        50        60\n```\n\n\n:::\n\n```{.r .cell-code}\ndf <- as.data.frame(mat)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Feature_1 Feature_2 Feature_3 Feature_4\nRow_1         21        31        41        51\nRow_2         22        32        42        52\nRow_3         23        33        43        53\nRow_4         24        34        44        54\nRow_5         25        35        45        55\nRow_6         26        36        46        56\nRow_7         27        37        47        57\nRow_8         28        38        48        58\nRow_9         29        39        49        59\nRow_10        30        40        50        60\n```\n\n\n:::\n:::\n\n\nTo get the contents of the fifth row, second column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[5, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[5, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35\n```\n\n\n:::\n:::\n\n\nWe show the following on matrices, but they work just the same on data.frames.\n\nIf you want to select an entire row or an entire column, you leave the row or \ncolumn index blank, but you ***must include a comma***:\n\nGet the first row:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFeature_1 Feature_2 Feature_3 Feature_4 \n       21        31        41        51 \n```\n\n\n:::\n:::\n\n\nGet the second column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Row_1  Row_2  Row_3  Row_4  Row_5  Row_6  Row_7  Row_8  Row_9 Row_10 \n    31     32     33     34     35     36     37     38     39     40 \n```\n\n\n:::\n:::\n\n\nNote that colnames and rownames were added to the matrix above for convenience \n- if they are absent, there are no labels above each element.\n\nYou can define ranges for both rows and columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[6:7, 2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feature_2 Feature_3 Feature_4\nRow_6        36        46        56\nRow_7        37        47        57\n```\n\n\n:::\n:::\n\n\nYou can use vectors to specify any combination of rows and columns.\n\nGet rows 2, 4, and 7 of columns 1, 4, and 3:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[c(2, 4, 7), c(1, 4, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feature_1 Feature_4 Feature_3\nRow_2        22        52        42\nRow_4        24        54        44\nRow_7        27        57        47\n```\n\n\n:::\n:::\n\n\nSince a matrix is a vector with 2 dimensions, you can also index the underlying vector \ndirectly. Regardless of whether a matrix was created by row or by column (default), the \ndata is stored and accessed by column. You can see that by converting the matrix to a \none-dimensional vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.vector(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45\n[26] 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n```\n\n\n:::\n:::\n\nsame as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45\n[26] 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n```\n\n\n:::\n:::\n\n\nFor example, 'mat' has 10 rows and 4 columns, therefore the 11th element is in row 1, \ncolumn 2 - this only works with matrices, not data.frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[11]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n:::\n\nis the same as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[1, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n:::\n\n\n### Matrix of indexes\n\nThis is quite less common, but potentially useful. It allows you to specify a series of \nindividual `[i, j]` indexes, i.e. is a way to select multiple individual non-contiguous \nelements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidm <- matrix(c(2, 4, 7, 4, 3, 1), 3)\nidm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    4\n[2,]    4    3\n[3,]    7    1\n```\n\n\n:::\n:::\n\n\nAn n-by-2 matrix can be used to index as a length n vector of `[row, colum]` indexes. \nTherefore, the above matrix, will return elements `[2, 4], [4, 3], [7, 1]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[idm]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 52 44 27\n```\n\n\n:::\n:::\n\n\n### Logical index {#matidl}\n\nIdentify rows with value greater than 36 on the second column:\n\nThe logical index for this operation is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[, 2] > 36\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Row_1  Row_2  Row_3  Row_4  Row_5  Row_6  Row_7  Row_8  Row_9 Row_10 \n FALSE  FALSE  FALSE  FALSE  FALSE  FALSE   TRUE   TRUE   TRUE   TRUE \n```\n\n\n:::\n:::\n\n\nIt can be used directly to index the matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[mat[, 2] > 36, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Feature_1 Feature_2 Feature_3 Feature_4\nRow_7         27        37        47        57\nRow_8         28        38        48        58\nRow_9         29        39        49        59\nRow_10        30        40        50        60\n```\n\n\n:::\n:::\n\n\nIndexing a matrix or a data.frame can return either a smaller matrix/data.frame or a \nvector.\n\nIn general, many R functions return the simplest R object that can hold the output.\nAs always, check function documentation to look for possible arguments that can change\nthis and what the default behavior is.\nIf you extract a column or a row, you get a vector:\n\nGet the third column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Row_1  Row_2  Row_3  Row_4  Row_5  Row_6  Row_7  Row_8  Row_9 Row_10 \n    41     42     43     44     45     46     47     48     49     50 \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(mat[, 3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\nYou can specify `drop = FALSE` to stop R from dropping the unused dimension and return a \nmatrix or data.frame of a single column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[, 3, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Feature_3\nRow_1         41\nRow_2         42\nRow_3         43\nRow_4         44\nRow_5         45\nRow_6         46\nRow_7         47\nRow_8         48\nRow_9         49\nRow_10        50\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[, 3, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Feature_3\nRow_1         41\nRow_2         42\nRow_3         43\nRow_4         44\nRow_5         45\nRow_6         46\nRow_7         47\nRow_8         48\nRow_9         49\nRow_10        50\n```\n\n\n:::\n:::\n\n\nCheck it is still a matrix or data.frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mat[, 3, drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(df[, 3, drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n## Lists {#indexlists}\n\nReminder: A list can contain elements of different classes and of different \nlengths:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(one = 1001:1004,\n          two = sample(seq(0, 100, .1), 10),\n          three = c(\"Neuro\", \"Cardio\", \"Radio\"),\n          four = median)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$one\n[1] 1001 1002 1003 1004\n\n$two\n [1] 29.0 63.9 53.9 47.0 44.4 84.4 32.4  4.0 82.4 14.6\n\n$three\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n\n$four\nfunction (x, na.rm = FALSE, ...) \nUseMethod(\"median\")\n<bytecode: 0x12bc32990>\n<environment: namespace:stats>\n```\n\n\n:::\n:::\n\n\n\n### Get *single* list element:\n\nYou can access a *single* list element using:\n\n- double brackets `[[` with either *name* or *integer position*\n- `$` followed by name of the element (therefore only works if elements are named)\n\nFor example, to access the third element:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx$three\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n:::\n\nsame as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n:::\n\n\nsame as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[\"three\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n:::\n\n\nTo access a list element programmatically, i.e. using a name or integer index \nstored in a variable, only the bracket notation works. Therefore, programmatically, you would always use double brackets to access different elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidi <- 3\nidc <- \"three\"\nx[[idi]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n\n```{.r .cell-code}\nx[[idc]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n:::\n\n\n### Get *one or more* list elements as a ***list***:\n\nYou can extract one or more list elements as a pruned list using\nsingle bracket `[` notation. Similar to indexing of a vector, this can be\neither a logical, integer, or character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$three\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n\n```{.r .cell-code}\nx[\"three\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$three\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n\n```{.r .cell-code}\nx[c(FALSE, FALSE, TRUE, FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$three\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n:::\n\n\nGet multiple elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$two\n [1] 29.0 63.9 53.9 47.0 44.4 84.4 32.4  4.0 82.4 14.6\n\n$three\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# same as\nx[c(\"two\", \"three\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$two\n [1] 29.0 63.9 53.9 47.0 44.4 84.4 32.4  4.0 82.4 14.6\n\n$three\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# same as\nx[c(FALSE, TRUE, TRUE, FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$two\n [1] 29.0 63.9 53.9 47.0 44.4 84.4 32.4  4.0 82.4 14.6\n\n$three\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n```\n\n\n:::\n:::\n\n\n### Recursive indexing of list\n\nGiven the following list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(PIDN = 2001:2020,\n          Dept = c(\"Neuro\", \"Cardio\", \"Radio\"),\n          Age = rnorm(20, 57, 1.3))\n```\n:::\n\n\nWe can access the 3rd element of the 2nd element:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[2]][3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Radio\"\n```\n\n\n:::\n:::\n\n\nor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[c(2, 3)]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Radio\"\n```\n\n\n:::\n:::\n\n\nThis is called recursive indexing and is perhaps more often\nused by accident, when one instead wanted to extract the 2nd and 3rd elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(2, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Dept\n[1] \"Neuro\"  \"Cardio\" \"Radio\" \n\n$Age\n [1] 56.61850 57.92260 57.56174 58.45535 59.04431 56.78473 59.33876 57.61936\n [9] 56.00509 56.47367 56.00955 55.93562 56.81072 57.55131 59.29390 54.98739\n[17] 56.00187 58.21258 58.00560 56.26664\n```\n\n\n:::\n:::\n\n\n### Flatten list\n\nYou can convert a list to a single vector containing all individual components of the \noriginal list using `unlist()`. Notice how names are automatically created based on the \noriginal structure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(alpha = sample(seq(100), 10),\n          beta = sample(seq(100), 10),\n          gamma = sample(seq(100), 10))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$alpha\n [1] 96 61 37 95 29 19 94 86 57 30\n\n$beta\n [1] 73 84 20  9 21  2 85 52 67 94\n\n$gamma\n [1]  8 37 20 83  2 41 87 14 13 35\n```\n\n\n:::\n\n```{.r .cell-code}\nunlist(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n alpha1  alpha2  alpha3  alpha4  alpha5  alpha6  alpha7  alpha8  alpha9 alpha10 \n     96      61      37      95      29      19      94      86      57      30 \n  beta1   beta2   beta3   beta4   beta5   beta6   beta7   beta8   beta9  beta10 \n     73      84      20       9      21       2      85      52      67      94 \n gamma1  gamma2  gamma3  gamma4  gamma5  gamma6  gamma7  gamma8  gamma9 gamma10 \n      8      37      20      83       2      41      87      14      13      35 \n```\n\n\n:::\n:::\n\n\nIf you want to drop the names, you can set the `use.names` argument to FALSE or wrap \nthe above in `unname()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(x, use.names = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 96 61 37 95 29 19 94 86 57 30 73 84 20  9 21  2 85 52 67 94  8 37 20 83  2\n[26] 41 87 14 13 35\n```\n\n\n:::\n\n```{.r .cell-code}\n# same as\nunname(unlist(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 96 61 37 95 29 19 94 86 57 30 73 84 20  9 21  2 85 52 67 94  8 37 20 83  2\n[26] 41 87 14 13 35\n```\n\n\n:::\n:::\n\n\n## Data frames {#indexdfs}\n\n::: callout-note\nIn data science and related fields the terms **filter** and **select** are \ncommonly used:\n\n- **Filter**: identify ***cases*** i.e. rows\n- **Select**: identify ***variables*** a.k.a. ***features*** i.e. columns\n:::\n\nWe've saw above that a data frame can be indexed in many ways similar to a \nmatrix, i.e. by defining rows and columns. At the same time, we know that a \ndata frame is a rectangular list. Like a list, its elements are vectors of any \ntype (integer, double, character, factor, and more) but, unlike a list, they \nhave to be of the same length. A data frame can also be indexed the same way as \na list and similar to list indexing, notice that some methods return a smaller \ndata frame, while others return vectors.  \n\n::: callout-tip\nYou can index a data frame using all the ways you can index a **list** and \nall the ways you can index a **matrix**.\n:::\n\nLet's create a simple data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.frame(Feat_1 = 21:25,\n                Feat_2 = rnorm(5),\n                Feat_3 = paste0(\"rnd_\", sample(seq(100), 5)))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Feat_1     Feat_2  Feat_3\n1     21  1.0465924 rnd_100\n2     22 -0.4623166  rnd_27\n3     23  1.1295668  rnd_10\n4     24 -1.4519094   rnd_1\n5     25 -2.4151783   rnd_8\n```\n\n\n:::\n:::\n\n\n### Get *single* column as a vector\n\nJust like in a list, using double brackets `[[` or the `$` operator\nreturns an element, i.e. a **vector**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx$Feat_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n:::\n\n\n### Get \"one or more\" columns as a data.frame\n\nAccessing a column by name using square brackets, returns a single-column \n**data.frame**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[\"Feat_2\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feat_2\n1  1.0465924\n2 -0.4623166\n3  1.1295668\n4 -1.4519094\n5 -2.4151783\n```\n\n\n:::\n:::\n\n\nAccessing a column by `[row, column]` either by position or name, returns a vector by \ndefault:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[, \"Feat_2\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n:::\n\n\nAs we saw earlier, we can specify `drop = FALSE` to return a `data.frame`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x[, 2, drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x[, \"Feat_2\", drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\nAs in lists, all indexing and slicing operations, with the exception of the `$` \nnotation, work with a variable holding either a column name of or an integer location:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidi <- 2\nidc <- \"Feat_2\"\nx[idi]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feat_2\n1  1.0465924\n2 -0.4623166\n3  1.1295668\n4 -1.4519094\n5 -2.4151783\n```\n\n\n:::\n\n```{.r .cell-code}\nx[idc]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feat_2\n1  1.0465924\n2 -0.4623166\n3  1.1295668\n4 -1.4519094\n5 -2.4151783\n```\n\n\n:::\n\n```{.r .cell-code}\nx[[idi]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n\n```{.r .cell-code}\nx[[idc]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n\n```{.r .cell-code}\nx[, idi]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n\n```{.r .cell-code}\nx[, idc]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0465924 -0.4623166  1.1295668 -1.4519094 -2.4151783\n```\n\n\n:::\n\n```{.r .cell-code}\nx[, idi, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feat_2\n1  1.0465924\n2 -0.4623166\n3  1.1295668\n4 -1.4519094\n5 -2.4151783\n```\n\n\n:::\n\n```{.r .cell-code}\nx[, idc, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feat_2\n1  1.0465924\n2 -0.4623166\n3  1.1295668\n4 -1.4519094\n5 -2.4151783\n```\n\n\n:::\n:::\n\n\nExtracting multiple columns returns a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[, 2:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feat_2  Feat_3\n1  1.0465924 rnd_100\n2 -0.4623166  rnd_27\n3  1.1295668  rnd_10\n4 -1.4519094   rnd_1\n5 -2.4151783   rnd_8\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x[, 2:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n### Get rows\n\nUnlike indexing a row of a matrix, indexing a row of a data.frame returns a single-row \ndata.frame, since it contains multiple columns of potentially different types:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Feat_1   Feat_2  Feat_3\n1     21 1.046592 rnd_100\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x[1, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\nConvert into a list using `c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(x[1, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Feat_1\n[1] 21\n\n$Feat_2\n[1] 1.046592\n\n$Feat_3\n[1] \"rnd_100\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(x[1, ]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nConvert into a (named) vector using `unlist()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(x[1, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            Feat_1             Feat_2             Feat_3 \n              \"21\" \"1.04659237125901\"          \"rnd_100\" \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(unlist(x[1, ]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n### Logical index {#dfidl}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x$Feat_1 > 22, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Feat_1    Feat_2 Feat_3\n3     23  1.129567 rnd_10\n4     24 -1.451909  rnd_1\n5     25 -2.415178  rnd_8\n```\n\n\n:::\n:::\n\n\n## Logical <-> Integer indexing\n\nIn this chapter, we have learned how to use both integer and logical indexes. \n\n::: callout-note\n- A logical index needs to be of the same dimensions as the object it is \nindexing (unless you really want to recycle values - see chapter on \n[vectorization](#vectorization)):  \n    you are specifying whether to include or exclude each element\n    \n- An integer index will be shorter than the object it is indexing:\n    you are specifying which subset of elements to include (or with a `-` in \n    front, which elements to exclude)\n:::\n\nIt's easy to convert between the two types.  \n\nFor example, start with a sequence of integers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 21:30\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 21 22 23 24 25 26 27 28 29 30\n```\n\n\n:::\n:::\n\n\nLet's create a logical index based on two inequalities:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_index <- x > 23 & x < 28\nlogical_index\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n### Logical to integer index with `which()`:\n\n\n::: callout-warning\nThe common mistake is to attempt to convert a logical index to an integer index using \n`as.integer()`. This results in a vector of 1's and 0's, NOT an integer index.  \n`which()` converts a logical index to an integer index.\n:::\n\n`which()` literally gives the position of all `TRUE` elements in a vector, thus \nconverting a logical to an integer index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninteger_index <- which(logical_index)\ninteger_index\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5 6 7\n```\n\n\n:::\n:::\n\n\ni.e. positions 4, 5, 6, 7 of the `logical_index` are TRUE\n\n\n::: callout-note\nA logical and an integer index are equivalent if they select the exact same elements\n:::\n\nLet's check than when used to index `x`, they both return the same result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[logical_index]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24 25 26 27\n```\n\n\n:::\n\n```{.r .cell-code}\nx[integer_index]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24 25 26 27\n```\n\n\n:::\n\n```{.r .cell-code}\nall(x[logical_index] == x[integer_index])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n### Integer to logical index\n\nOn the other hand, if we want to convert an integer index to a logical index, we can \nbegin with a logical vector of the same length or dimension as the object we want to \nindex with all FALSE values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_index_too <- vector(length = length(x))\nlogical_index_too\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nAnd use the integer index to replace the corresponding elements to TRUE:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_index_too[integer_index] <- TRUE\nlogical_index_too\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nThis, of course, is the same as the logical index we started with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(logical_index == logical_index_too)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Exclude cases using an index\n\nVery often, we want to use an index, whether logical or integer, to exclude \ncases instead of to select cases.  To do that with a logical integer, we simply \nuse an exclamation point in front of the index to negate each element \n(convert each TRUE to FALSE and each FALSE to TRUE):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_index\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n!logical_index\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[!logical_index]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21 22 23 28 29 30\n```\n\n\n:::\n:::\n\n\nTo exclude elements using an integer index, R allows you to use negative \nindexing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-integer_index]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21 22 23 28 29 30\n```\n\n\n:::\n:::\n\n\n::: callout-note\nTo get the complement of an index, you negate a logical index \n(`!logical_index`) or you subtract an integer index (`-integer_index`).\n:::\n\n## Resources\n\n[\"Indexing vectors\" in *An Introduction to R*](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Index-vectors)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}