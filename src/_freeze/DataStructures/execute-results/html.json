{
  "hash": "6d7837a4865697b4056537b05da4ac69",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk:\n    comment: \"\"\n---\n\n# Data Structures {#sec-datastructures}\n\n## Overview\n\nThere are 5 main data structures in R:\n<br><br>\n\n| Data Structure  | Dimensionality     | Contents        | Notes\n|----------------:|-------------------:|----------------:|:--------------------------|\n| **Vector**      | 1D                | homogeneous     | the \"base\" object\n| **Matrix**      | 2D                | homogeneous     | a vector with 2 dimensions\n| **Array**       | ND                | homogeneous     | a vector with N dimensions\n| **List**        | 1D; can be nested | heterogeneous   | a collection of any R objects, each of any length\n| **Data frame**  | 2D                | heterogeneous   | a special kind of list: a collection of (column) vectors of any type, all of the same length\n\n**Vectors** are homogeneous data structures which means all of their elements have \nto be of the same type (see @sec-datatypes), e.g. integer, double, character, \nlogical. \n\n**Matrices** and arrays are vectors with more dimensions,\nand as such, are also homogeneous.\n\n**Lists** are the most flexible. Their elements can be any R objects, including \nlists, and therefore can be nested.\n\n**Data frames** are a special kind of list. Their elements are one or more \nvectors, which can be of any type, and form columns. Therefore a data.frame is a \ntwo-dimensional data structure where rows typically correspond to cases \n(e.g. individuals) and columns represent variables. As such, data.frames\nare the most common data structure for statistical analysis.\n<br><br>\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![R Data Structure summary - Best to read through this chapter first and then refer back to this figure](./R_datastructures.png){fig-align='center' width=100%}\n:::\n:::\n\n\n::: callout-tip\n**Check object class with `class()`**.\n\n**Check object class and contents' types with `str()`**.\n:::\n\n::: callout-caution\nMany errors in R occur because a variable is, or gets coerced to, the wrong \ntype or class by accident.\nThat's why it is essential to be able to:\n\n- check the type of a variable using `typeof()` or `class()`\n\n- convert (coerce) between types or classes using `as.*` functions\n::: \n\n## Vectors\n\nA vector is the most basic and fundamental data structure in R. \nOther data structures are made up of one or more vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 3, 5, 7)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 5 7\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\nA vector has `length()` but no `dim()`, e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\n### Initializing a vector\n\nSee [Initializing vectors](#initvectors)\n\n## Matrices\n\nA matrix is a **vector with 2 dimensions**.  \n\nTo create a matrix, you pass a vector to the `matrix()` function and specify \nnumber of rows using `nrow` and/or number of columns using `ncol`;\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(21:50,\n            nrow = 10, ncol = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3]\n [1,]   21   31   41\n [2,]   22   32   42\n [3,]   23   33   43\n [4,]   24   34   44\n [5,]   25   35   45\n [6,]   26   36   46\n [7,]   27   37   47\n [8,]   28   38   48\n [9,]   29   39   49\n[10,]   30   40   50\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\nA matrix has length (`length(x)`) equal to the number of all (i, j) elements or \nnrow * ncol (if `i` is the row index and `j` is the column index) and \ndimensions (`dim(x)`) as expected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  3\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n### Construct by row vs. by column\n\nBy default, vectors are constructed by column (`byrow = FALSE`), e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(1:20, nrow = 10, ncol = 2, byrow = FALSE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2]\n [1,]    1   11\n [2,]    2   12\n [3,]    3   13\n [4,]    4   14\n [5,]    5   15\n [6,]    6   16\n [7,]    7   17\n [8,]    8   18\n [9,]    9   19\n[10,]   10   20\n```\n\n\n:::\n:::\n\n\nYou can set the `byrow` argument to `TRUE` to fill the matrix by row instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(1:20, nrow = 10, ncol = 2, byrow = TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2]\n [1,]    1    2\n [2,]    3    4\n [3,]    5    6\n [4,]    7    8\n [5,]    9   10\n [6,]   11   12\n [7,]   13   14\n [8,]   15   16\n [9,]   17   18\n[10,]   19   20\n```\n\n\n:::\n:::\n\n\n### Initialize a matrix {#initmatrix}\n\nYou can initialize a matrix with some constant value, e.g. 0:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(0, nrow = 6, ncol = 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]    0    0    0    0\n[3,]    0    0    0    0\n[4,]    0    0    0    0\n[5,]    0    0    0    0\n[6,]    0    0    0    0\n```\n\n\n:::\n:::\n\n\n::: callout-note\nTo initialize a matrix with `NA` values, it is most efficient to use `NA` of the\nappropriate type, e.g. `NA_real_` for a numeric matrix, `NA_character_` for a\ncharacter matrix, etc. See [NA types](#natypes).\n:::\n\nFor example, to initialize a numeric matrix with `NA` values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(NA_real_, nrow = 6, ncol = 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA\n[4,]   NA   NA   NA   NA\n[5,]   NA   NA   NA   NA\n[6,]   NA   NA   NA   NA\n```\n\n\n:::\n:::\n\n\n### Bind vectors by column or by row\n\nUse `cbind` (\"column-bind\") to convert a set of input vectors to columns of a \n**matrix**. The vectors must be of the same length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- cbind(1:10, 11:20, 41:50)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3]\n [1,]    1   11   41\n [2,]    2   12   42\n [3,]    3   13   43\n [4,]    4   14   44\n [5,]    5   15   45\n [6,]    6   16   46\n [7,]    7   17   47\n [8,]    8   18   48\n [9,]    9   19   49\n[10,]   10   20   50\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\nSimilarly, you can use `rbind` (\"row-bind\") to convert a set of input vectors \nto rows of a **matrix**. The vectors again must be of the same length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rbind(1:10, 11:20, 41:50)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    2    3    4    5    6    7    8    9    10\n[2,]   11   12   13   14   15   16   17   18   19    20\n[3,]   41   42   43   44   45   46   47   48   49    50\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\n### Combine matrices\n\n`cbind()` and `rbind()` can be used to combine two or more matrices together - \nor vector and matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(matrix(1, 5, 2), matrix(2, 5, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    1    2    2    2    2\n[2,]    1    1    2    2    2    2\n[3,]    1    1    2    2    2    2\n[4,]    1    1    2    2    2    2\n[5,]    1    1    2    2    2    2\n```\n\n\n:::\n:::\n\n\n## Arrays\n\nArrays are **vectors with dimensions**.  \nYou can have 1D, 2D or any number of dimensions, i.e. ND arrays.\n\n### One-dimensional (\"1D\") array\n\nA 1D array is just like a vector but of class `array` and with `dim(x)` equal \nto `length(x)`. Remember, vectors have only `length(x)` and undefined `dim(x)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nxa <- array(1:10, dim = 10)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(xa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"array\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(xa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(xa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(xa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\nIt is rather unlikely you will need to use a 1D array instead of a vector.\n\n### Two-dimensional (\"2D\") array\n\nA 2D array is a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:40, dim = c(10, 4))\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\ndim(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  4\n```\n\n\n:::\n:::\n\n\n### Multi-dimensional (\"ND\") array\n\nYou can build an N-dimensional array:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:60, dim = c(5, 4, 3))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   21   26   31   36\n[2,]   22   27   32   37\n[3,]   23   28   33   38\n[4,]   24   29   34   39\n[5,]   25   30   35   40\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   41   46   51   56\n[2,]   42   47   52   57\n[3,]   43   48   53   58\n[4,]   44   49   54   59\n[5,]   45   50   55   60\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"array\"\n```\n\n\n:::\n:::\n\nYou can provide names for each dimensions using the `dimnames` argument. It \naccepts a list where each elements is a character vector of length equal to the \ndimension length. Using the same example as above, we pass three character \nvector of length 5, 4, and 3 to match the length of the dimensions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:60,\n            dim = c(5, 4, 3),\n            dimnames = list(letters[1:5],\n                            c(\"alpha\", \"beta\", \"gamma\", \"delta\"),\n                            c(\"x\", \"y\", \"z\")))\n```\n:::\n\n\n3D arrays can be used to represent color images. Here, just for fun, we use \n`rasterImage()` to show how you would visualize such an image:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(sample(1:255, 432, TRUE), dim = c(12, 12, 3))\npar(\"pty\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"m\"\n```\n\n\n:::\n\n```{.r .cell-code}\npar(pty = \"s\")\nplot(NULL, NULL,\n     xlim = c(0, 100), ylim = c(0, 100),\n     axes = F, ann = F, pty = \"s\")\nrasterImage(x/255, 0, 0, 100, 100)\n```\n\n::: {.cell-output-display}\n![](DataStructures_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## Lists\n\nTo define a list, we use `list()` to pass any number of objects.  \nIf these objects are passed as named arguments, the names will be used as \nelement names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(one = 1:4,\n          two = sample(seq(0, 100, .1), 10),\n          three = c(\"mango\", \"banana\", \"tangerine\"),\n          four = median)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ one  : int [1:4] 1 2 3 4\n $ two  : num [1:10] 33.4 70.3 82.2 2.9 58.6 21 27.3 6 6.3 84.8\n $ three: chr [1:3] \"mango\" \"banana\" \"tangerine\"\n $ four :function (x, na.rm = FALSE, ...)  \n```\n\n\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n### Nested lists\n\nSince each element can be any object, we can build nested lists:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(alpha = letters[sample(26, 4)],\n          beta = sample(12),\n          gamma = list(i = rnorm(10),\n                       j = runif(10),\n                       k = seq(0, 1000, length.out = 10)))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$alpha\n[1] \"g\" \"z\" \"h\" \"i\"\n\n$beta\n [1]  6  1 11  4 10  3  7  9  2  8  5 12\n\n$gamma\n$gamma$i\n [1]  0.47763881 -0.68136534  0.02900407 -2.14215449  0.24241352  0.04474057\n [7]  1.53657948 -1.34927120  1.86174362 -3.24810849\n\n$gamma$j\n [1] 0.8413278 0.9515669 0.4848407 0.5505351 0.7239982 0.5843004 0.3433791\n [8] 0.3017487 0.4780124 0.5447676\n\n$gamma$k\n [1]    0.0000  111.1111  222.2222  333.3333  444.4444  555.5556  666.6667\n [8]  777.7778  888.8889 1000.0000\n```\n\n\n:::\n:::\n\n\nIn the example above, alpha, beta, and gamma, are x's elements.\nNotice how the length of the list refers to the number of these top-level \nelements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n### Initialize a list\n\nWhen setting up experiments, it can be very convenient to set up and empty\nlist, where results will be stored (e.g. using a [for-loop](#forloops)):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- vector(\"list\", 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n\n[[4]]\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n### Add element to a list\n\nYou can add a new elements to a list by assigning directly to an element\nthat doesn't yet exist, which will cause it to be created:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1:10, b = rnorm(10))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$b\n [1] -0.3751287  1.3538853 -0.8493012  1.6419656  0.2910162  0.4836877\n [7] -0.3441973  0.3703074  0.3503174 -0.9295175\n```\n\n\n:::\n\n```{.r .cell-code}\nx$c <- 30:21\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$b\n [1] -0.3751287  1.3538853 -0.8493012  1.6419656  0.2910162  0.4836877\n [7] -0.3441973  0.3703074  0.3503174 -0.9295175\n\n$c\n [1] 30 29 28 27 26 25 24 23 22 21\n```\n\n\n:::\n:::\n\n\n### Combine lists\n\nYou can combine lists with `c()`, just like vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(q = 11:14, r = letters[11:14])\nl2 <- list(s = LETTERS[21:24], t = 100:97)\nx <- c(l1, l2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$q\n[1] 11 12 13 14\n\n$r\n[1] \"k\" \"l\" \"m\" \"n\"\n\n$s\n[1] \"U\" \"V\" \"W\" \"X\"\n\n$t\n[1] 100  99  98  97\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n## Combining different types with `c()`\n\nIt's best to use `c()` to either combine elements of the same type into a \nvector, or to combine lists.\n\nAs we've seen, if all arguments passed to `c()` are of a single type, you get a \nvector of that type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(12.9, 94.67, 23.74, 46.901)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12.900 94.670 23.740 46.901\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\nIf arguments passed to `c()` are a mix of numeric and character, they all get \n***coerced to character***. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- c(23.54, \"mango\", \"banana\", 75))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"23.54\"  \"mango\"  \"banana\" \"75\"    \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\nIf you pass more types of objects (which cannot be coerced to character) you \nget a list, since it is the only structure that can support all of them together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- c(42, mean, \"potatoes\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 42\n\n[[2]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x135452f58>\n<environment: namespace:base>\n\n[[3]]\n[1] \"potatoes\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n##  Data frames {#sec-dataframestruc}\n\n::: callout-note\nA data frames is a **special type of list** where each element has the same \nlength and forms a column, resulting in a 2D structure. Unlike matrices, each \ncolumn can contain a different data type.\n:::\n\ndata.frames are usually created with named elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.frame(Feat_1 = 1:5,\n                Feat_2 = rnorm(5),\n                Feat_3 = paste0(\"rnd_\", sample(seq(100), 5)))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Feat_1     Feat_2 Feat_3\n1      1  0.1856828  rnd_8\n2      2  1.9473681 rnd_80\n3      3  1.5540269 rnd_67\n4      4 -1.0799091 rnd_35\n5      5 -0.9201912 rnd_58\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t5 obs. of  3 variables:\n $ Feat_1: int  1 2 3 4 5\n $ Feat_2: num  0.186 1.947 1.554 -1.08 -0.92\n $ Feat_3: chr  \"rnd_8\" \"rnd_80\" \"rnd_67\" \"rnd_35\" ...\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x$Feat_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n::: callout-note\nUnlike a matrix, the elements of a data.frame are its columns, not the \nindividual values in each position. Therefore the length of a data.frame\nis equal to the number of columns.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:100, 10)\nlength(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\ndf <- as.data.frame(mat)\nlength(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\nJust like with lists, you can add new columns to a data.frame using \nassignment to a new element, i.e. column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.frame(PIDN = sample(8001:9000, 10, TRUE),\n                Age = rnorm(10, 48, 2.9))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   PIDN      Age\n1  8405 50.52164\n2  8518 51.26875\n3  8486 52.14841\n4  8855 50.04322\n5  8062 51.84860\n6  8238 49.88148\n7  8602 39.79031\n8  8238 51.82812\n9  8734 48.44644\n10 8637 47.31140\n```\n\n\n:::\n\n```{.r .cell-code}\nx$Weight <- rnorm(10, 84, 1.5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   PIDN      Age   Weight\n1  8405 50.52164 83.89401\n2  8518 51.26875 86.49058\n3  8486 52.14841 86.81414\n4  8855 50.04322 82.92206\n5  8062 51.84860 82.51698\n6  8238 49.88148 82.26698\n7  8602 39.79031 85.70450\n8  8238 51.82812 84.47379\n9  8734 48.44644 83.76192\n10 8637 47.31140 81.86091\n```\n\n\n:::\n:::\n\n\n## Generating sequences\n\nOther than assigning individual elements explicitly with `c()`, there are\nmultiple ways to create numeric sequences.\n\nColon notation allows generating a simple integer sequence:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n`seq(from, to, by)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 10, .5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0\n[16]  8.5  9.0  9.5 10.0\n```\n\n\n:::\n:::\n\n\n`seq(from, to, length.out = n)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(-5, 12, length.out = 11)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -5.0 -3.3 -1.6  0.1  1.8  3.5  5.2  6.9  8.6 10.3 12.0\n```\n\n\n:::\n:::\n\n\n`seq(object)` generates a sequence of length equal to `length(object)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n`seq_along(object)` is the optimized version of `seq(object)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n`seq(n)` is equivalent to `1:n`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n```\n\n\n:::\n\n```{.r .cell-code}\n# same output as\n1:12\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n```\n\n\n:::\n:::\n\n\n`seq_len(n)` is an optimized version of `seq(n)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_len(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n```\n\n\n:::\n:::\n\n\n## Naming object elements\n\nAll objects' elements can be named.\n\n### Vectors\n\nYou can create a vector with named elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSBP = c(before = 179, after = 118)\nSBP\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbefore  after \n   179    118 \n```\n\n\n:::\n:::\n\n\nUse `names()` to get a vector's elements' names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(SBP)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"before\" \"after\" \n```\n\n\n:::\n:::\n\n\nYou can add names to an existing, unnamed, vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- c(112, 120)\nnames(N)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(N) <- c(\"Cases\", \"Controls\")\nN\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Cases Controls \n     112      120 \n```\n\n\n:::\n:::\n\n\nMatrices and data frames can have column names (`colnames`) and row names \n(`rownames`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxm <- matrix(1:15, 5)\nxdf <- as.data.frame(xm)\ncolnames(xm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(xdf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"V1\" \"V2\" \"V3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrownames(xm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(xm) <- colnames(xdf) <- paste0(\"Feature\", seq(3))\nrownames(xm) <- rownames(xdf) <- paste0(\"Case\", seq(5))\nxm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feature1 Feature2 Feature3\nCase1        1        6       11\nCase2        2        7       12\nCase3        3        8       13\nCase4        4        9       14\nCase5        5       10       15\n```\n\n\n:::\n\n```{.r .cell-code}\nxdf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Feature1 Feature2 Feature3\nCase1        1        6       11\nCase2        2        7       12\nCase3        3        8       13\nCase4        4        9       14\nCase5        5       10       15\n```\n\n\n:::\n:::\n\n\nLists are vectors so they have `names`. These can be defined when a list is \ncreated using the name-value pairs or added/changed at any time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(HospitalName = \"CaliforniaGeneral\",\n          ParticipatingDepartments = c(\"Neurology\", \"Psychiatry\", \"Neurosurgery\"),\n          PatientIDs = 1001:1018)\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HospitalName\"             \"ParticipatingDepartments\"\n[3] \"PatientIDs\"              \n```\n\n\n:::\n:::\n\n\nAdd/Change names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(x) <- c(\"Hospital\", \"Departments\", \"PIDs\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Hospital\n[1] \"CaliforniaGeneral\"\n\n$Departments\n[1] \"Neurology\"    \"Psychiatry\"   \"Neurosurgery\"\n\n$PIDs\n [1] 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015\n[16] 1016 1017 1018\n```\n\n\n:::\n:::\n\n\nRemember that data a frame is a special type of list. Therefore in data frames \n`colnames` and `names` are equivalent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nnames(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n```\n\n\n:::\n:::\n\n\n::: callout-tip\nNote: As we saw, matrices have `colnames()` and `rownames()` Using `names()` on a \nmatrix will assign names to *individual elements*, as if it was a long vector.\n:::\n\n## Initialize - coerce - test data structures\n\nThe following table lists the functions to *initialize*, *coerce* \n(=convert), and *test* the core data structures, which are shown in more \ndetail in the following paragraphs:\n\n| **Initialize**                      | **Coerce**        | **Test**           |\n|------------------------------------:|------------------:|-------------------:|\n| `matrix(NA, nrow = x, ncol = y)`    | `as.matrix(x)`    | `is.matrix(x)`     |\n| `array(NA, dim = c(x, y, z))`       | `as.array(x)`     | `is.array(x)`      |\n| `vector(mode = \"list\", length = x)` | `as.list(x)`      | `is.list(x)`       |\n| `data.frame(matrix(NA, x, y))`      | `as.data.frame(x)`| `is.data.frame(x)` |\n\n## Attributes\n\nR objects may have some builtin attributes but you can add arbitrary attributes \nto any R object. These are used to store additional information, sometimes \ncalled metadata.  \n\n### Print all attributes\n\nTo print an object's attributes, use `attributes`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n$class\n[1] \"data.frame\"\n\n$row.names\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n[109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n[127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n[145] 145 146 147 148 149 150\n```\n\n\n:::\n:::\n\n\nThis returns a named list. In this case we got names, class, and row.names of \nthe iris data frame.  \n\n### Get or set specific attributes\n\nYou can assign new attributes using `attr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- c(1:10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(x, \"name\") <- \"Very special vector\"\n```\n:::\n\n\nPrinting the vector after adding a new attribute, prints the attribute name \nand value underneath the vector itself:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\nattr(,\"name\")\n[1] \"Very special vector\"\n```\n\n\n:::\n:::\n\n\nOur trusty `str` function will print attributes as well:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:10] 1 2 3 4 5 6 7 8 9 10\n - attr(*, \"name\")= chr \"Very special vector\"\n```\n\n\n:::\n:::\n\n\n#### A matrix is a vector - a closer look\n\nLet's see how a matrix is literally just a vector with assigned dimensions.  \nStart with a vector of length 20:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:20\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n```\n\n\n:::\n:::\n\nThe vector has no attributes - yet:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\nTo convert to a matrix, we would normally pass our vector to the `matrix()` \nfunction and define number of rows and/or columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxm <- matrix(x, 5)\nxm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(xm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$dim\n[1] 5 4\n```\n\n\n:::\n:::\n\n\nJust for demonstration, let's instead directly add a dimension attribute to our \nvector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(x, \"dim\") <- c(5, 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\nJust like that, we have created a matrix.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}