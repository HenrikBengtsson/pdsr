---
execute:
  cache: true
knitr:
  opts_chunk: 
    comment: ''
---
# Aggregate {#sec-aggregate}

R includes a number of commands to apply functions on splits of your data.
`aggregate()` is a powerful tools to perform such "group-by" operations.

The function accepts either:

- a formula as the first argument and a data.frame passed to the `data` argument
- a vector as the first argument and a factor passed to the `by` argument 

We shall see how to perform each operation below with 
each approach. 

The formula interface might be easier to work with 
interactivly on the console. 
Note that while you *can* programatically create a formula, it is easier to use
vector inputs when calling `aggregate()` programmatically. 

For this example, we shall use the penguin data from the **palmerpenguins**
package:

```{r}
library(palmerpenguins)
str(penguins)
```

See example below for 1 or multiple variables by 1 or more groups using either 
the formula interface, or working directly on objects with `$`-indexing or 
using `with()`:

## Single variable by single grouping

Note that the formula method defaults to na.action = na.omit

Using the formula interface:

```{r}
aggregate(bill_length_mm ~ species,
          penguins, mean, na.rm = TRUE)
```

Directly working with vectors:

```{r}
aggregate(penguins$bill_length_mm,
          by = list(penguins$species),
          mean, na.rm = TRUE)
```

Note that, unlike the formula notation, if your input is a vector which is
unnamed, the output columns are also unnamed.

If instead of passing a vector, you pass a data.frame or list with one named
element, the output includes the name:

```{r}
aggregate(penguins["bill_length_mm"],
          by = list(Species = penguins$species),
          mean, na.rm = TRUE)
```

```{r}
aggregate(list(Bill_length = penguins$bill_length_mm),
          by = list(Species = penguins$species),
          mean, na.rm = TRUE)
```

Using `with()`:

```{r}
with(penguins,
     aggregate(bill_length_mm,
               by = list(species),
               mean, na.rm = TRUE))
```

## Multiple variables by single grouping

formula:

```{r}
aggregate(cbind(bill_length_mm, flipper_length_mm) ~ species,
          penguins, mean)
```

vectors:

```{r}
aggregate(penguins[, c("bill_length_mm", "flipper_length_mm")],
          by = list(penguins$species),
          mean, na.rm = TRUE)
```

`with()` + column names:

```{r}
with(penguins,
     aggregate(cbind(bill_length_mm, flipper_length_mm),
               by = list(species),
               mean, na.rm = TRUE))
```

## Single variable by multiple groups

formula:

```{r}
aggregate(bill_length_mm ~ species + island, penguins, mean)
```

vectors:

```{r}
aggregate(penguins$bill_length_mm,
          by = list(penguins$species, penguins$island),
          mean, na.rm = TRUE)
```

`with()` + column names:

```{r}
with(penguins,
     aggregate(bill_length_mm,
               by = list(species, island),
               mean, na.rm = TRUE))
```

## Multiple variables by multiple groupings

formula:

```{r}
aggregate(cbind(bill_length_mm, flipper_length_mm) ~ species + island,
          penguins, mean)
```

vectors:

```{r}
aggregate(penguins[, c("bill_length_mm", "flipper_length_mm")],
          by = list(penguins$species, penguins$island),
          mean, na.rm = TRUE)
```

`with()` + column names:

```{r}
with(penguins,
     aggregate(cbind(bill_length_mm, flipper_length_mm),
               by = list(species, island),
               mean, na.rm = TRUE))
```

## See also

- [`tapply()`]({#tapply}) for an alternative methods of applying function on 
subsets of a single variable (probably faster)
- For large datasets, it is recommended to use [data.table](#sec-datatable) for 
fast group-by data summarization.
