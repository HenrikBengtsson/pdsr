# Indexing - Subsetting - Slicing {#indexing}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 10, fig.height = 5,
                      comment = NA, cache = TRUE) 
options(rt.theme = "lightgrid")
options(rt.fit.theme = "lightgrid")
```

```{r, comment="", results="asis", echo=FALSE}
old.hooks <- fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE)
```

## Indexing
### Vectors
```{r}
x <- rnorm(10)
x
x[5:10]
```

### Matrices
A matrix is rectangular and can contain elements of the same class only.  
Numeric matrix:
```{r}
x <- cbind(rnorm(5), rnorm(5), rnorm(5))
x
```

Character matrix:
```{r}
x <- matrix(letters[1:15], 5)
x
```

Matrix & data frame indexing: `[row, column]`

```{r}
x[1, 1]
```

```{r}
x[1, ]
x[, 1]
```

```{r}
x[2:4, 3:2]
```

Note: A matrix element is a cell. Contrast with data frames where an element is a column. This affects how elementwise operations are applied on matrices and columns - e.g. using `sapply()`

### Lists
A list can contain elements of different class and of different length:
```{r}
(x <- list(one = 1:4,
          two = sample(seq(0, 100, .1), 10),
          three = c("mango", "banana", "tangerine"),
          four = median))
```

Access a list element, i.e. vector with `$` or double brackets:
```{r}
x$three
class(x$three)
x[["three"]]
class(x[["three"]])
```

To access an element with a name or integer index, only the bracket notation works:
```{r}
idi <- 3
idc <- "three"
x[[idi]]
x[[idc]]
```

Single bracket indexing returns a list:
```{r}
x[idi]
x[idc]
class(x[idi])
class(x[idc])
```

Extract multiple list elements with single brackets:
```{r}
x[2:3]
class(x[2:3])
```

Beware the confusing recursive indexing. The following extracts the 3rd element of the 2nd element of the list:
```{r}
x[[2:3]]
```

You can convert a list to one lone vector containing all the individual components of the original list using `unlist()`:
```{r}
(x <- list(alpha = sample(seq(100), 10),
          beta = sample(seq(100), 10),
          gamma = sample(seq(100), 10)))
unlist(x)
```


### Data frames
A data.frame in R is a special type of list. Like a list, its elements are vectors of any type (integer, double, character, factor, and more) but, unlike a list, they have to be of the same length, since a data.frame is a rectangular structure. There are different ways to index and slice a data frame. Beware that some return a smaller data.frame, while others return vectors.  
You can index a data frame using all the ways you can index a list and all the ways you can index a matrix.

```{r}
x <- data.frame(Feat_1 = 1:5,
                Feat_2 = rnorm(5),
                Feat_3 = paste0("rnd_", sample(seq(100), 5)))
```

#### Extract column(s)
Just like in a list, using the `$` operator returns an element, i.e. a **vector**:
```{r}
x$Feat_2
class(x$Feat_2)
```

Accessing a column by name with square brackets, returns a single-column **data.frame**:
```{r}
x["Feat_2"]
class(x["Feat_2"])
```
Again, similar to a list, if you double the square brackets, you access the element within the data.frame, which is a vector:
```{r}
x[["Feat_2"]]
```
Accessing a column by `[row, column]` either by position or name, return a vector by default:
```{r}
x[, 2]
class(x[, 2])
x[, "Feat_2"]
class(x[, "Feat_2"])
```
The above happens, because by default the argument `drop` is set to `TRUE`. Set it to `FALSE` to return a `data.frame`:
```{r}
class(x[, 2, drop = FALSE])
class(x[, "Feat_2", drop = FALSE])
```

With the exception of the `$` notation, all other indexing and slicing operations work with a variable holding either a character name of a column or an integer location:
```{r}
idi <- 2
idc <- "Feat_2"
x[idi]
x[idc]
x[[idi]]
x[[idc]]
x[, idi]
x[, idc]
x[, idi, drop = F]
x[, idc, drop = F]

```

Extracting multiple columns returns a data.frame (since it cannot be "dropped" into a vector)
```{r}
x[, 2:3]
class(x[, 2:3])
```

#### Extract rows
A row is a small data.frame, since it contains multiple columns:
```{r}
x[1, ]
class(x[1, ])
```

Convert into a list using `c`:
```{r}
c(x[1, ])
class(c(x[1, ]))
```
Convert into a (named) vector using `unlist()`:
```{r}
unlist(x[1, ])
class(unlist(x[1, ]))
```

## Logical <-> Integer indexing
We have integer and logical indices. It's easy to convert one to the other.  
In general, logical indices should be the length of your object / dimension (unless you really want values to be recycled) but integer indices will be shorter.

```{r}
index <- iris$Sepal.Length > mean(iris$Sepal.Length)
index
```
```{r}
head(iris[index, ])
```

### Logical to integer index with `which`:
```{r}
index_i <- which(iris$Sepal.Length > mean(iris$Sepal.Length))
index_i
table(index)
length(index_i)
```

```{r}
head(iris[index_i, ])
```

### Integer to logical index
```{r}
index_l <- vector(length = NROW(iris))
index_l[index_i] <- T
```

### Complement of an index
To get the complement, you negate the logical index (`!`) and you subtract the integer (`-`):
```{r}
all(iris[!index_l, ] == iris[-index_i, ])
```

## `subset()`
`subset()` allows you to filter cases that meet certain conditions using the `subset` argument, and optionally also select columns using the `select` argument:
```{r}
head(iris)
iris_sl.gt.med <-  subset(iris, Sepal.Length > median(Sepal.Length))
```

Note: You can use the column name Sepal.Length directly, i.e. unquoted and you don't need to use `iris$Sepal.Length`. This is calles Non-Standard Evaluation (NSE)
```{r}
x <- data.frame(one = 1:10,
                two = rnorm(10),
                group = c(rep("alpha", 4),  rep("beta", 6)))
subset(x, subset = two > 0, select = two)
subset(x, two > 0, -one)
subset(x, two > 0, two:one)
subset(x, two > 0, two:group)
```

## `split()`
Split a data frame into multiple data frames by groups defined by a factor:
```{r}
x_by_group <- split(x, x$group)
```

## `with`
With `with`, you can access data.frame column without quoting or using the `$` operator:
```{r}
with(x, x[group == "alpha", ])
with(x, x[two > 0, ])
```

