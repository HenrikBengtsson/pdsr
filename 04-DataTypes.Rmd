# Data Types {#types}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 10, fig.height = 5,
                      comment = NA, cache = TRUE) 
options(rt.theme = "lightgrid")
options(rt.fit.theme = "lightgrid")
```

```{r, comment="", results="asis", echo=FALSE}
old.hooks <- fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE)
```

```{block, type="Info"}
In R, everything is an object.

Every "action" is a function.

[Functions](#functions) are also objects, which means they can be passed as arguments to functions or returned from other functions.

We shall see the relevance of this, for example, in the [Loop Functions](#loopfns) chapter.
```

## Base types

R includes a number of builtin data types.  

These are defined by the R core team: users cannot define their own data types, but they can define their own classes - see section on [Classes and Object-Oriented Programming](#classes).  

Some of the more popular data types in R are:

* Logical (a.k.a. [Boolean](https://en.wikipedia.org/wiki/Boolean_data_type))
* Numeric, integer
* Numeric, [double](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)
* Character
* Environment
* Closure (i.e. function)

```{block, type="Warning"}
Many errors in R occur because a variable is, or gets coerced to, the wrong type by accident.
```

```{block, type="Info"}
**Check variable types with `typeof()` and/or `str()`.**
```

## Assignment

Use `<-` for all assignments

```{r}
x <- 3
# You can add comments within code blocks using the usual "#" prefix
```

Typing the name of an object...

```{r}
x
```
...is equivalent to printing it

```{r}
print(x)
```

You can also place any assignment in parentheses and this will perform the assignment and print the object:

```{r}
(x <- 3)
```

Note: While you *could* use the equal sign '=' for assignment, you should only use it when passing arguments to functions.  

You can assign the same value to multiple objects - this can be useful when initializing variables.

```{r}
x <- z <- init <- 0
x
z
init
```

Excitingly, R allows assignment in the opposite direction as well:

```{r}
10 -> x
x
```

We shall see later that the `->` assignment can be convenient at the end of a [pipe](https://class.lambdamd.org/progdatscir/functions.html#the-pipe-operator).

You can even do this, which is fun (?) but unlikely to be useful:

```{r}
x <- 7 -> z
x
z
```

Use `c()` to combine multiple values into a vector - this is one of the most widely used R functions:

```{r}
x <- c(-12, 3.5, 104)
x
```


## Initialize - coerce - test (types)

The following summary table lists the functions to *initialize*, *coerce* (=convert), and *test* the core data types, which are shown in more detail in the following paragraphs:

| **Initialize** | **Coerce**        | **Test**          |
|---------------:|------------------:|------------------:|
| `logical(n)`   | `as.logical(x)`   | `is.logical(x)`   |
| `integer(n)`   | `as.integer(x)`   | `is.integer(x)`   |
| `double(n)`    | `as.double(x)`    | `is.double(x)`    |
| `character(n)` | `as.character(x)` | `is.character(x)` |

## Logical 

If you are writing code, use `TRUE` and `FALSE`.  
On the console, you can abbreviate to `T` and `F`.

```{r}
a <- c(TRUE, FALSE)
a <- c(T, F)
x <- 4
b <- x > 10
b
str(b)
typeof(b)
```

## Integer

Create a range of integers using colon notation `start:end`:

```{r}
(x <- 11:15)
typeof(x)
str(x)
```

Note that assigning an integer defaults to type double:

```{r}
x <- 1
typeof(x)
str(x)
```

You can force it to be stored as integer by adding an `L` suffix:

```{r}
x <- 1L
typeof(x)
str(x)
```
```{r}
x <- c(1L, 3L, 5L)
str(x)
```

## Double

```{r}
x <- c(1.2, 3.4, 10.987632419834556)
x
typeof(x)
str(x)
```

## Character

A character vector consists of one or more elements, each of which consists of one or more actual characters, i.e. it is **not** a vector of single characters. (The length of a character vector is the number of individual elements, and is not related to the number of characters in each element)

```{r}
x <- "word"
typeof(x)
length(x)
```

```{r}
(x <- c("a", "b", "gamma", "delta"))
typeof(x)
length(x)
```

## Environment

Defining your own environments is probably for advanced use only:

```{r}
x <- new.env()
x$name <- "Guava"
x$founded <- 2020
x
typeof(x)
```

## Closure (function)

Closures are functions - they contain their own variable definitions.  
Read more on [functions](#functions).

```{r}
square <- function(x) x^2
square(3)
typeof(square)
```

## Initialize vectors

You can create / initialize vectors of specific type with the `vector` command and specifying a `mode` or directly by calling the relevant function:

```{r}
(xl <- vector(mode = "logical", length = 10))
(xd <- vector(mode = "double", length = 10))
(xn <- vector(mode = "numeric", length = 10)) # same as "double"
(xi <- vector(mode = "integer", length = 10))
(xc <- vector(mode = "character", length = 10))
```

These are aliases of the `vector` command above (print their source code to see for yourself)

```{r}
xl <- logical(10)
xd <- double(10)
xn <- numeric(10) # same as double
xi <- integer(10)
xc <- character(10)
```

## Explicit coercion

We can explicitly convert objects of one type to a different type using `as.*` functions:

```{r}
(x <- c(1.2, 2.3, 3.4))
(x <- as.logical(x))
(x <- as.double(x))
(x <- as.numeric(x))
(x <- as.integer(x))
(x <- as.character(x))
```

Logical vectors are converted to 1s and 0s as expected:  

TRUE becomes 1 and FALSE becomes 0

```{r}
x <- c(TRUE, TRUE, FALSE)
as.numeric(x)
```

Note that converting from numeric to logical **anything other than zero is TRUE**:

```{r}
x <- seq(-2, 2, .5)
as.logical(x)
```

Not all conversions are possible.  
There is no meaningful/consistent way to convert a character vector to numeric.  
The following outputs NA values and prints a (helpful) error message.

```{r}
x <- c("mango", "banana", "tangerine")
as.numeric(x)
```

## Implicit coercion

Remember, the language tries to make life easier and will often automatically coerce from one class to another to make requested operations possible.

For example, you can sum a logical vector.  
It will automatically be converted to numeric as we saw earlier.

```{r}
x <- c(TRUE, TRUE, FALSE)
sum(x)
```

On the other hand, you cannot sum a factor, for example.  
You get an error with an explanation:

```{r error = TRUE}
x <- factor(c("mango", "banana", "mango"))
sum(x)
```

```{block, type="Note"}
Note: We had to add `error = TRUE` in the Rmarkdown's code block's options (not visible in the HTML output), because otherwise compilation of the Rmarkdown document would stop at the error.
```

If for some reason it made sense, you could explicitly coerce to numeric and then sum:

```{r}
x <- factor(c("mango", "banana", "mango"))
sum(as.numeric(x))
```

## Missing Values

Missing values in any data type - logical, integer, double, or character - are coded using `NA`.  
To check for the presence of `NA` values, use `is.na()`:

```{r}
(x <- c(1.2, 5.3, 4.8, NA, 9.6))
is.na(x)
```

```{r}
(x <- c("mango", "banana", NA, "sugar", "ackee"))
is.na(x)
```

```{r}
(x <- c(T, T, F, T, F, F, NA))
is.na(x)
```

```{block, type="Note"}
Any operations on an `NA` results in `NA`
```

```{r}
x <- c(1.2, 5.3, 4.8, NA, 9.6)
x*2
```
Multiple functions that accept as input an object with multiple values (a vector, a matrix, a data.frame, etc.) will return `NA` if *any* element is `NA`:

```{r}
mean(x)
median(x)
sd(x)
min(x)
max(x)
range(x)
```

First, make sure `NA` values represent legitimate missing data and not some error.  
Then, decide how you want to handle it.

In all of the above commands you can pass `na.rm = TRUE` to ignore `NA` values:

```{r}
mean(x, na.rm = TRUE)
median(x, na.rm = TRUE)
sd(x, na.rm = TRUE)
min(x, na.rm = TRUE)
max(x, na.rm = TRUE)
range(x, na.rm = TRUE)
```

The chapter on [Handling Missing Data](#missingdata) describes some approaches to handling missing data in the context of statistics or modeling, commonly supervised learning.
