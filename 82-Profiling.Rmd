# Benchmarking & Profiling {#profiling}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 5, fig.height = 5,
                      comment = NA, cache = TRUE) 
options(rt.theme = "lightgrid")
options(rt.fit.theme = "lightgrid")
```

```{r, comment="", results="asis", echo=FALSE}
old.hooks <- fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE)
```

**Benchmarking** is the process of timing the execution of code for the purpose of comparison. For example, you can compare the execution time of a program in two different systems, e.g. a laptop and a high performance server. Another common case is to compare the performance of two different programs that produce the same output on the same computer. 

**Profiling** refers to timing the different steps of a program to identify bottlenecks and potential targets for optimization.

## `system.time()`: Time the execution of an expression 

The base package's `system.time()` function allows you to measure the execution time of an R expression.

```{r}
system.time(rnorm(9999999))
```

"elapsed" time is real time in seconds.

"user" and "system" are time used by the CPU on different types of tasks (see `?proc.time`).

As always, you can pass any R expression within curly brackets:

```{r}
x <- rnorm(9999)
system.time({
    for (i in 2:9999) {
      x[i]
      x[i] <- x[i]^3
    }
})
```

You can use `replicate()` to get a measure of time over multiple executions and average it:

```{r}
set.seed(2020)
x <- matrix(rnorm(500000), 5000)
y <- 12 + x[, 3] + x[, 5]^2 + x[, 7]^3 + rnorm(5000)
fit.glm <- function(x, y) glm.fit(x, y)
    
fit.glm_time10 <- replicate(10, system.time(fit.glm(x, y))[[1]])
```

```{r, fig.width=2.5, fig.height=5}
boxplot(fit.glm_time10)
```

## Compare execution times with `microbenchmark::microbenchmark()`

The [**microbenchmark**](https://github.com/joshuaulrich/microbenchmark/) package's `microbenchmark()` function allows you to time the execution of multiple expressions with sub-millisecond accuracy. It will execute each command a number of times as defined by the `times` argument (default = 100), and output statistics of execution time per expression in nanoseconds. Using `plot()` on the output produces a boxplot comparing the time distributions.

```{r}
# install.packages("microbenchmark")
library(microbenchmark)
```

### Example: Group means

Let's perform a simple mean-by-group operation and compare three different approaches. As an example, we use the `flights` dataset from the **nycflights13** package which includes data on 336,776 flights that departed from NY area airports in 2013. The data comes as a [tibble](https://tibble.tidyverse.org/), and we create data.frame and data.table versions.th

```{r warning=FALSE}
library(data.table)
library(dplyr)
library(nycflights13)
class(flights)
dim(flights)
flights_df <- as.data.frame(flights)
flights_dt <- as.data.table(flights)
```

Compare performance of the same operation using different functions:

* base R `aggregate()` with formula input
* base R `aggregate()` with list input
* base R `tapply()`

```{r}
flights_aggregate_formula <- function() {
  aggregate(arr_delay ~ carrier, 
            data = flights_df,
            mean, na.rm = TRUE)
}
  
flights_aggregate <- function() {
  aggregate(flights_df$arr_delay, 
            by = list(flights_df$carrier), 
            mean, na.rm = TRUE)
}

flights_tapply <- function() {
  tapply(flights_df$arr_delay, 
         flights_df$carrier, 
         mean, na.rm = TRUE)
}

groupmean_3x <- microbenchmark(
  aggregate_formula = flights_aggregate_formula(),
  aggregate = flights_aggregate(),
  tapply = flights_tapply()
  )
class(groupmean_3x)
```

Print microbenchmark's output:

```{r}
groupmean_3x
```

There is a `plot()` method for microbenchmark objects:

```{r}
plot(groupmean_3x)
```

## Profile a function with `profvis()`

The **profvis** package's `profvis()` function provides an interactive output to visualize the time spent in different calls within a program.

```{r fig.width=7, fig.height=5}
profvis({
  hf <- read.csv("https://archive.ics.uci.edu/ml/machine-learning-databases/00519/heart_failure_clinical_records_dataset.csv")
  str(hf)
  lt5 <- which(sapply(hf, \(i) length(unique(i))) < 5)
  for (i in lt5) hf[, i] <- factor(hf[, i])
  index_numeric <- which(sapply(hf, is.numeric))
  par(mfrow = c(1, length(index_numeric)))
  for (i in index_numeric) boxplot(hf[, i])
  par(mfrow = c(1, 1))
})
```
