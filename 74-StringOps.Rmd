# String Operations {#stringops}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 5, fig.height = 5,
                      comment = NA, cache = TRUE) 
```

## Reminder: create, coerce, check

* `character()`: Initialize empty character vector
* `as.character()`: Coerce any vector to a character vector
* `is.character()`: Check object is character

```{r}
x <- character(10)
x
```

```{r}
v <- c(10, 20, 22, 43)
x <- as.character(v)
x
```

```{r}
x <- c("PID", "Age", "Sex", "Handedness")
is.character(x)
```

## `cat()`: Concatenate and **print**

`cat()` concatenates strings in order to print to screen (console) or to file. 

It **does not return any object**. It is therefore useful to produce informative messages in your programs.

```{r}
sbp <- 130
temp <- 98.4
cat("The blood pressure was", sbp, "and the temperature was", temp, "\n")
```

Use the `file` argument to write to a text file. The `append` argument allows using
multiple `cat()` calls to append to the same file.

## `paste()`: Concatenate character vectors into a vector

`paste()` and `paste0()` are particularly useful commands.

In it simplest form, they acts like `as.character()`:

```{r}
v <- c(10, 20, 22, 43)
paste(v)
```

But their main job is to combine strings from multiple vectors elementwise:

```{r}
id = c("001", "010", "018", "020", "021", "051")
dept = c("Emergency", "Cardiology", "Neurology",
         "Anesthesia", "Surgery", "Psychiatry")
id
dept
```

```{r}
paste(id, dept)
```

The `sep` argument defines the separator:

```{r}
paste(id, dept, sep = "+++")
```

`paste0()` is an alias for the commonly used `paste(..., sep = "")`:

```{r}
paste0(id, dept)
```

As with other vectorized operations, value recycling can be very convenient:

```{r}
paste0("Feature_", 1:10)
```

The argument `collapse` helps output a *single* character element after collapsing with some string:

```{r}
paste0("Feature_", 1:10, collapse = ", ")
```

## `nchar()`: Get number of characters in element

`nchar()` counts the number of characters in each **element** of type character in a vector:

```{r}
x <- c("a", "bb", "ccc")
nchar(x)
```

## `substr()`: Get substring

`substr()` allows you to get and set individual (literal) characters from a character (R base type) vector, by position:

### Extract

e.g. Get characters 1-3:

```{r}
x <- c("001Emergency", "010Cardiology", "018Neurology", 
       "020Anesthesia", "021Surgery", "051Psychiatry")
substr(x, start = 1, stop = 3)
```

Neither `start` nor `stop` need to be valid character positions.  
For example, if you want to get all characters from the fourth one to the last one, you can specify a very large `stop`

```{r}
substr(x, 4, 99)
```

If you start with too high an index, you end up with empty strings:

```{r}
substr(x, 20, 24)
```

**Note:** `substring()` is also available, with similar syntax to `substr()`: (first, last) instead of (start, stop). It is available for compatibility with S (check its source code to see how it's an alias for `substr()`)

### Replace

```{r}
x <- c("Jan_1987")
x
```

Replace the first three letters:

```{r}
substr(x, 1, 3) <- "Feb"
x
```

Note that if the replacement is longer, it is "cropped" to the length of the substring being replaced:

```{r}
substr(x, 1, 3) <- "April"
x
```

## `strsplit()`: Split strings

`strsplit()` allows you to split a character vector elements based on any character or [regular expression](#regex)

```{r}
x <- "This is one sentence"
strsplit(x, " ")
```

```{r}
x <- "14,910"
strsplit(x, ",")
```

As with any functions, you can compose string operations in complex ways (though it may often be considerably easier to perform multiple separate operations instead):

```{r}
x <- c("1,950", "2,347")
x
```

```{r}
lapply(strsplit(x, ","), function(i) 
  paste(i, c("thousand", "dollars"), collapse = " and "))
```

## String formatting

### Change case with `toupper()` and `tolower()`

```{r}
features <- c("id", "age", "sex", "sbp", "dbp", "hct", "urea", "creatinine")
features
toupper(features)
tolower(features)
```

### `abbreviate()`

`abbreviate()` allows to reduce elements of a character vector to short, unique abbreviations of a minimumn length (defaults to 4)

```{r}
x <- c("Emergency", "Cardiology", "Surgery", "Anesthesia", "Neurology", "Psychiatry", "Clinical Psychology")
abbreviate(x)
abbreviate(x, minlength = 4)
abbreviate(x, minlength = 5)
```

## Pattern matching

A very common task in programming is to find +/- replace string patterns in a vector of strings.  
`grep()` and `grepl()` help find strings that contain a given pattern.  
`sub()` and `gsub()` help find and replace strings.

### `grep()`: Get an **integer** index of elements that include a pattern

```{r}
x <- c("001Age", "002Sex", "010Temp", "014SBP", "018Hct", "022PFratio", "030GCS", "112SBP-DBP")
grep(pattern = "SBP", x = x)
```

`grep()`'s `value` arguments which defaults to `FALSE`, allows returning the matched string itself (the value of the element) instead of its integer index:

```{r}
grep("SBP", x, value = TRUE)
```

### `grepl()`: Get a **logical** index of elements that include a pattern

`grepl()` is similar to `grep()`, but returns a logical index instead:

```{r}
grepl("SBP", x)
```

### `sub()`: Find replace **first** match of a pattern

```{r}
x <- c("The most important variable was PF ratio. Other significant variables are listed in the supplementary information.")
sub(pattern = "variable", replacement = "feature", x = x)
```

"First match" refers to each element of a character vector:

```{r}
x <- c("var 1, var 2", "var 3, var 4")
sub("var", "feat", x)
```

### `gsub()`: Find and replace **all** matches of a pattern

```{r}
x <- c("The most important variable was PF ratio. Other significant variables are listed in the supplementary information.")
gsub(pattern = "variable", replacement = "feature", x = x)
```

"All matches" means all matches across all elements:

```{r}
x <- c("var 1, var 2", "var 3, var 4")
gsub("var", "feat", x)
```

## Regular expressions {#regex}

Regular expressions allow you to perform flexible pattern matching. For example, you can look for a pattern specifically at the beginning or the end of a word, or for a variable pattern with certain characteristics.

Regular expressions are very powerful and heavily used. They exist in multiple programming languages - with many similarities and some differences in their syntax.

There are many rules in defining regular expressions and take a little getting used to. You can read the R manual by typing `?base::regex`.  

Some of the most important rules are liste below:

### Match a pattern at the beginning of a line/string with `^`/`\\<`:

Use the caret sign `^` in the **beginning** of a pattern to only match strings that begin with this pattern.  
pattern `012` matches both 2nd and 3rd elements:

```{r}
x <- c("001xyz993", "012qwe764", "029aqw012")
x
grep("012", x)
```

By adding `^` or `\\<`, only the 2nd element matches:

```{r}
grep("^012", x)
grep("\\<012", x)
```

### Match a pattern at the end of a line/string with `$`/`\\>`

The dollar sign `$` is used at the **end** of a pattern to only match strings which end with this pattern:

```{r}
x
grep("012$", x)
grep("012\\>", x)
```

```{r}
x <- c("1one", "2one", "3two", "3three")
grep("one$", x)
grep("one\\>", x)
```

### `.`: Match any character

```{r}
grep("e.X", c("eX", "enX", "ennX", "ennnX", "ennnnX"))
```

### `+`: Match preceding character one or more times:

```{r}
grep("en+X", c("eX", "enX", "ennX", "ennnX", "ennnnX"))
```


### `{n}`: Match preceding character `n` times:

```{r}
grep("en{2}X", c("eX", "enX", "ennX", "ennnX", "ennnnX"))
```

### `{n,}`: Match preceding character `n` or more times:

```{r}
grep("en{2,}X", c("eX", "enX", "ennX", "ennnX", "ennnnX"))
```

### `{n,m}`: Match preceding character at least `n` times and no more than `m` times:

```{r}
grep("en{2,3}X", c("eX", "enX", "ennX", "ennnX", "ennnnX"))
```

### Escaping metacharacters

The following are defined as metacharacters, because they have special meaning within a regular expression: `. \ | ( ) [ { ^ $ * + ?`.  
If you want to match one of these characters itself, you must "escape" it using a double backslash:

```{r}
x <- c("dn3ONE", "d.3TWO", "dx3FIVE")
grep("d\\.3", x)
```

### Character classes

You can define a set of characters to be matched using square brackets. Any number of the characters in the set will be matched.

For example match and replace `$` and/or `@` with an underscore:

```{r}
x <- c("Feat1$alpha", "Feat2$gamma@5", "Feat9@zeta2")
gsub("[$@]", "_", x)
```

#### Predefined character classes

A number of character classes are predefined. Slightly confusingly, they are themselves surrounded by brackets and to use them as a character class, you need a seconds set of brackets around them. Some of the most common ones include:  

* `[:alnum:]`: alphanumeric, i.e. all letters and numbers
* `[:alpha:]`: all letters
* `[:digit:]`: all numbers
* `[:lower:]`: all lowercase letters
* `[:upper:]`: all uppercase letters
* `[:punct:]`: all punctuation characters (! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~.)
* `[:blank:]`: all spaces and tabs
* `[:space:]`: all spaces, tabs, newline characters, and some more

Let's look at some examples using them.

Here we use `[:digit:]` to remove all numbers:

```{r}
x <- c("001Emergency", "010Cardiology", "018Neurology", "020Anesthesia", 
       "021Surgery", "051Psychiatry")
x
gsub("[[:digit:]]", "", x)
```

We can use `[:alpha:]` to remove all letters instead:

```{r}
gsub("[[:alpha:]]", "", x)
```

We can use a caret `^` in the beginning of a character class to match any character *not* in the character set:

```{r}
x <- c("001$Emergency", "010@Cardiology", "018*Neurology", "020!Anesthesia", 
       "021!Surgery", "051*Psychiatry")
gsub("[^[:alnum:]]", "_", x)
```

### Combine character classes

Use `|` to match from multiple character classes:

```{r}
x <- c("123#$%alphaBeta")
gsub("[[:digit:]|[:punct:]]", "", x)
```

```{block, type="rmdinfo"}
For more information on regular expressions, start by reading the built-in documentation: `?regex`
```
