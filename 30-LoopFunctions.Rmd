# Loop Functions {#loopfns}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 10, fig.height = 5,
                      comment = NA, cache = TRUE) 
```

Loop functions are some of the most widely used R functions. They replace longer expressions created with a `for` loop, for example.  
They can result in more compact and readable code and are often faster to execute than a `for` loop.  

* `apply()`: Apply function over array margins (i.e. over one or more dimensions)
* `lapply()`: Return a *list* where each element is the result of applying a function to each element of the input
* `sapply()`: Same as `lapply()`, but returns the simplest possible R object (instead of always returning a list)
* `vapply()`: Same as `sapply()`, but you pre-specify the return type: this is safer and may also be faster
* `tapply()`: Apply a function to elements of groups defined by a factor
* `mapply()`: Multivariate version of `sapply()`: Apply a function using the first elements of the inputs vectors, then using the second, third, and so on

```{r FigRDataStructures, echo = FALSE, fig.align = 'center', fig.cap = "`*apply()` function family summary (Best to read through this chapter first and then refer back to this figure)"}
knitr::include_graphics("./Rapplyfam.png")
```

Before starting to use the above functios, we need to learn about anonymous functions, which are often used within the apply functions.

## Anonymous functions

Anonymous functions are just like regular functions but they are not assigned to an object - i.e. they are not "named".  
They are usually passed as arguments to other functions to be used once, hence no need to name them.  
In R, anonymous functions are often used with the apply family of functions.  

Example of a simple regular function:

```{r}
squared <- function(x) {
  x^2
}
```

Because this is a short function definition, it can also be written in a single line without curly brackets:

```{r}
squared <- function(x) x^2
```

The equivalent anonymous function is the same minus the assignment:

```{r}
function(x) x^2
```

Let's use the `squared` function within `sapply()` to square the first four columns of the iris dataset. We wrap the function around `head()` to print the first six lines only:

```{r}
head(iris[, 1:4])
iris_sq <- sapply(iris[, 1:4], squared)
head(iris_sq)
```

Let's do the same as above, but this time using an anonymous function:

```{r}
iris_sqtoo <- sapply(iris[, 1:4], function(x) x^2)
head(iris_sqtoo)
```

The entire anonymous function definition is passed in the function argument (`FUN` in the R documentation).

## `apply()`

```{block, type="Info"}
`apply()` applies a function over one (or more) dimensions of an array of 2 dimensions or more (this includes matrices) or a data frame.
```
 
Let's calculate the mean value of each of the first four columns of the iris dataset:

```{r}
x <- iris[, -5]
iris_column_mean <- 
  apply(x,          # array with 'dim' attribute, most commonly 2D matrix or data.frame
        MARGIN = 2, # integer vector or character indicating dimensions over which 'FUN' will be applied
        FUN = mean) # function to apply
iris_column_mean
```

```{block, type="Note"}
Hint: It is possibly easiest to think of the "MARGIN" as the ***dimension you want to keep***.  
In the above case, we want the mean for each variable, i.e. we want to keep columns and collapse rows.
```

The above is equivalent to:

```{r}
iris_column_mean <- numeric(ncol(x))
names(iris_column_mean) <- names(x)

for (i in seq(x)) {
  iris_column_mean[i] <- mean(x[, i])
}
iris_column_mean
```

If you wanted to get the mean of the rows (makes little sense in this case):

```{r}
head(apply(x, 1, mean))
```

```{block, type="Note"}
`apply()` only works on objects with a define `dim()`
```

```{block, type="None"}
Try to think why you can't use `apply()` to apply a function `fn()` on a vector `v`.

...

...


Because that would be `fn(v)`
```

## `lapply()`

```{block, type="Info"}
`lapply()` applies a function on each of the elements of its input.  
```


Note: The 'elements' of a data frame are its columns (remember, a data frame is a list with equal-length elements). The 'elements' of a matrix are each cell one by one, by column. Therefore `lapply()` has a very different effect on a data frame and a matrix. `lapply()` is commonly used to iterate over the columns of a data frame.

```{r}
iris.median <- lapply(iris[, -5], median)
iris.median
```

The above is equivalent to:

```{r}
iris.median <- vector("list", 4)
names(iris.median) <- colnames(iris[, -5])
for (i in 1:4) {
  iris.median[[i]] <- median(iris[, 1])
}
```

## `sapply()`

`sapply()` is an alias for `lapply()`, followed by a call to `simplify2array()`.  
(Check the source code for `sapply()`: type `sapply()` at the console and hit Enter).  


```{block, type="Note"}
The output of `sapply()` will be the simplest R object that can hold the data type(s) resulting from the operations.
```

```{r}
iris.median <- sapply(iris[, -5], median)
iris.median
```

```{r}
iris.summary <- data.frame(Mean = sapply(iris[, -5], mean),
                           SD = sapply(iris[, -5], sd))
iris.summary
```

## `vapply()`

Much less commonly used (possibly *underused*) than `lapply()` or `sapply()`, `vapply()` allows you to specify what the expected output looks like - e.g. a numeric vector of a certain length.  
This can have two advantages:

- It is safer against errors
- It will sometimes be a little faster

You add the argument `FUN.VALUE` which must be of the correct **type** and **length** of the expected result.

```{r}
iris.median <- vapply(iris[, -5], median, FUN.VALUE = .1)
```

```{r}
minmax <- function(x) {
  c(min(x), max(x))
}
out <- vector("numeric", length = 2)
iris.minmax <- vapply(iris[, -5], minmax, out)
```

If the output does not match, we get an informative error:

```{r error = TRUE}
out <- vector("numeric", length = 2)
iris.min <- vapply(iris[, -5], min, out)
```

## `tapply()`

`tapply()` is one way (of many) to apply a function on **subgroups of data** as defined by one or more factors.  
In the following example, we calculate the mean Sepal.Length by species on the iris dataset:

```{r}
mean_Sepal.Length_by_Species <- tapply(iris$Sepal.Length, iris$Species, mean)
mean_Sepal.Length_by_Species
```

The above is equivalent to:

```{r}
species <- levels(iris$Species)
mean_Sepal.Length_by_Species <- vector("numeric", length(species))
names(mean_Sepal.Length_by_Species) <- species

for (i in seq(species)) {
  mean_Sepal.Length_by_Species[i] <- 
    mean(iris$Sepal.Length[iris$Species == species[i]])
}
mean_Sepal.Length_by_Species
```

## `mapply()`

```{r}
raise <- function(x, power) x^power
x <- 2:6
p <- 6:2
out <- mapply(raise, x, p)
out
```

The above is equivalent to:

```{r}
out <- vector("numeric", 6)
for (i in seq(5)) {
  out[i] <- raise(x[i], p[i])
}
```

## Iterating over a sequence instead of an object

With `lapply()`, `sapply()` and `vapply()` there is a very simple trick that may often come in handy. Instead of iterating over elements of an object, you can iterate over an integer index of the elements and use it accordingly in the anonymous function.  
This alternative approach is much closer to how we would use an integer sequence in a `for` loop.  
It will be much clearer through an example:

Get the mean of the first four columns of iris:

```{r}
# original way: iterate through elements i.e. columns:
sapply(iris[, -5], function(i) mean(i))

# alternative way: iterate over integer index of elements:
sapply(1:4, function(i) mean(iris[, i]))

# equivalent to:
for (i in 1:4) {
  mean(iris[, i])
}
```

Notice that in the alternative approach, since you are not passing the object (iris, here) as the input to `lapply()`, therefore it needs to be specified within the anonymous function.

## `*apply()`ing on matrices vs. data frames

To consolidate some of what was learned above, let's focus on the difference between working on a matrix vs. a data frame.  
First, let's create a matrix and a data frame with the same data:

```{r}
amat <- matrix(21:70, 10)
colnames(amat) <- paste0("Feature_", 1:ncol(amat))
amat
adf <- as.data.frame(amat)
adf
```

We've seen that with `apply()` we specify the dimension to operate on and it works the same way on both matrices and data frames:

```{r}
apply(amat, 2, mean)
apply(adf, 2, mean)
```

However, `sapply()` (and `lapply()`, `vapply()`) acts on ***each element*** of the object, therefore it is not meaningful to pass a matrix to it:

```{r}
sapply(amat, mean)
```
The above returns the mean of each element, i.e. the element itself, which is pointless.

Since a data frame is a list, and its columns are its elements, it works great for column operations on data frames:

```{r}
sapply(adf, mean)
```

If you want to use `sapply()` on a matrix, you could iterate over an integer sequence as shown in the previous section:

```{r}
sapply(1:ncol(amat), function(i) mean(amat[, i]))
```

This is shown to help emphasize the differences between the function and the data structures. In practice, you would use `apply()` on a matrix.
