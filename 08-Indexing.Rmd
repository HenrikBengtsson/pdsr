# Indexing - Subsetting - Slicing {#indexing}

```{r echo = FALSE}
knitr::opts_chunk$set(fig.width = 10, fig.height = 5,
                      comment = NA, cache = TRUE) 
```

## Indexing

The main indexing operator in R is the square bracket `[`.
Indexing is 1-based, meaning the first item of any collection is 1.
(If you are wondering why we are even mentioning this, know that many programming language use [0-based indexing](https://en.wikipedia.org/wiki/Zero-based_numbering#Computer_programming))

### Vectors

Get the 5th element of a vector:

```{r}
x <- rnorm(10)
x
x[5]
```

Get elements 6 through 9 of the same vector:

```{r}
x[6:9]
```

### Matrices

Reminder:

- A matrix is a 2D vector and contains elements of one type only (numeric, integer, character, factor).  
- A data frame is a 2D list and each column can contain different type of data.

Numeric matrix:

```{r}
mat <- matrix(1:40, 10)
df <- as.data.frame(mat)
```

To index a 2D structure, whether a matrix or data frame, we use `[row, column]`

To get the contents of the fifth row, second column:

```{r}
mat[5, 2]
df[5, 2]
```

If you want to select an entire row or an entire column, you leave the row or column index blank, but - necessarily - use a comma:

Get the first row:

```{r}
df[1, ]
```

Get the second column:

```{r}
df[, 2]
```

You can define ranges for both rows and columns:

```{r}
df[6:7, 2:4]
```

You can return rows and or columns reversed too if desired:

```{r}
df[6:7, 4:2]
```

### Lists

Reminder: A list can contain elements of different class and of different length:

```{r}
(x <- list(one = 1:4,
          two = sample(seq(0, 100, .1), 10),
          three = c("mango", "banana", "tangerine"),
          four = median))
```

You can access a list element with:

- `$` followed by name of element (therefore only works if elements are named)
- using double brackets `[[` with either name or integer index

To access the third element:

```{r}
x$three

x[["three"]]
class(x[["three"]])
x[[3]]
```

To access an element with a name or integer index, only the bracket notation works:
```{r}
idi <- 3
idc <- "three"
x[[idi]]
x[[idc]]
```

Single bracket indexing returns a list:
```{r}
x[idi]
x[idc]
class(x[idi])
class(x[idc])
```

Extract multiple list elements with single brackets:
```{r}
x[2:3]
class(x[2:3])
```

Beware the confusing recursive indexing. The following extracts the 3rd element of the 2nd element of the list:
```{r}
x[[2:3]]
```

You can convert a list to one lone vector containing all the individual components of the original list using `unlist()`:
```{r}
(x <- list(alpha = sample(seq(100), 10),
          beta = sample(seq(100), 10),
          gamma = sample(seq(100), 10)))
unlist(x)
```


### Data frames
A data.frame in R is a special type of list. Like a list, its elements are vectors of any type (integer, double, character, factor, and more) but, unlike a list, they have to be of the same length, since a data.frame is a rectangular structure. There are different ways to index and slice a data frame. Beware that some return a smaller data.frame, while others return vectors.  
You can index a data frame using all the ways you can index a list and all the ways you can index a matrix.

```{r}
x <- data.frame(Feat_1 = 1:5,
                Feat_2 = rnorm(5),
                Feat_3 = paste0("rnd_", sample(seq(100), 5)))
```

#### Extract column(s)
Just like in a list, using the `$` operator returns an element, i.e. a **vector**:
```{r}
x$Feat_2
class(x$Feat_2)
```

Accessing a column by name with square brackets, returns a single-column **data.frame**:
```{r}
x["Feat_2"]
class(x["Feat_2"])
```
Again, similar to a list, if you double the square brackets, you access the element within the data.frame, which is a vector:
```{r}
x[["Feat_2"]]
```
Accessing a column by `[row, column]` either by position or name, return a vector by default:
```{r}
x[, 2]
class(x[, 2])
x[, "Feat_2"]
class(x[, "Feat_2"])
```
The above happens, because by default the argument `drop` is set to `TRUE`. Set it to `FALSE` to return a `data.frame`:
```{r}
class(x[, 2, drop = FALSE])
class(x[, "Feat_2", drop = FALSE])
```

With the exception of the `$` notation, all other indexing and slicing operations work with a variable holding either a character name of a column or an integer location:
```{r}
idi <- 2
idc <- "Feat_2"
x[idi]
x[idc]
x[[idi]]
x[[idc]]
x[, idi]
x[, idc]
x[, idi, drop = F]
x[, idc, drop = F]

```

Extracting multiple columns returns a data.frame (since it cannot be "dropped" into a vector)
```{r}
x[, 2:3]
class(x[, 2:3])
```

#### Extract rows
A row is a small data.frame, since it contains multiple columns:
```{r}
x[1, ]
class(x[1, ])
```

Convert into a list using `c`:
```{r}
c(x[1, ])
class(c(x[1, ]))
```
Convert into a (named) vector using `unlist()`:
```{r}
unlist(x[1, ])
class(unlist(x[1, ]))
```

## Logical <-> Integer indexing
We have integer and logical indices. It's easy to convert one to the other.  
In general, logical indices should be the length of your object / dimension (unless you really want values to be recycled) but integer indices will be shorter.

```{r}
index <- iris$Sepal.Length > mean(iris$Sepal.Length)
index
```
```{r}
head(iris[index, ])
```

### Logical to integer index with `which`:
```{r}
index_i <- which(iris$Sepal.Length > mean(iris$Sepal.Length))
index_i
table(index)
length(index_i)
```

```{r}
head(iris[index_i, ])
```

### Integer to logical index
```{r}
index_l <- vector(length = NROW(iris))
index_l[index_i] <- T
```

### Complement of an index
To get the complement, you negate the logical index (`!`) and you subtract the integer (`-`):
```{r}
all(iris[!index_l, ] == iris[-index_i, ])
```

## `subset()`
`subset()` allows you to filter cases that meet certain conditions using the `subset` argument, and optionally also select columns using the `select` argument:
```{r}
head(iris)
iris_sl.gt.med <-  subset(iris, Sepal.Length > median(Sepal.Length))
```

Note: You can use the column name Sepal.Length directly, i.e. unquoted and you don't need to use `iris$Sepal.Length`. This is calles Non-Standard Evaluation (NSE)
```{r}
x <- data.frame(one = 1:10,
                two = rnorm(10),
                group = c(rep("alpha", 4),  rep("beta", 6)))
subset(x, subset = two > 0, select = two)
subset(x, two > 0, -one)
subset(x, two > 0, two:one)
subset(x, two > 0, two:group)
```

## `split()`
Split a data frame into multiple data frames by groups defined by a factor:
```{r}
x_by_group <- split(x, x$group)
```

## `with`
With `with`, you can access data.frame column without quoting or using the `$` operator:
```{r}
with(x, x[group == "alpha", ])
with(x, x[two > 0, ])
```

